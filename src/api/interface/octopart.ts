// This document was generated by https://transform.tools/graphql-to-typescript
// using the https://api.nexar.com/graphql/ schema

export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
	[K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
	ID: string;
	String: string;
	Boolean: boolean;
	Int: number;
	Float: number;
	Map: any;
	Time: any;
	/** The name scalar represents a valid GraphQL name as specified in the spec and can be used to refer to fields or types. */
	Name: any;
	/** The built-in `Decimal` scalar type. */
	Decimal: any;
	/** The `DateTime` scalar represents an ISO-8601 compliant date time type. */
	DateTime: any;
};

export type Query = {
	__typename?: "Query";
	/** Fetches an object given its ID. */
	node?: Maybe<Node>;
	/** Lookup nodes by a list of IDs. */
	nodes: Array<Maybe<Node>>;
	/** Search for workspaces associated with this account. */
	desWorkspaces: Array<DesWorkspace>;
	/** Search a specific workspace by its unique identifier. */
	desWorkspaceById?: Maybe<DesWorkspace>;
	/** Get a list of workspace locations. */
	desWorkspaceLocations: Array<DesWorkspaceLocation>;
	/** Gets the specified settings. */
	desSettings: Array<Maybe<Scalars["String"]>>;
	/** Gets life cycle definitions. */
	desLifeCycleDefinitions: Array<DesLifeCycleDefinition>;
	/** Gets the first allowed life cycle by the content kind. */
	desLifeCycleDefinitionByContentTypeKind: DesLifeCycleDefinition;
	/** Gets revision naming schemes. */
	desRevisionNamingSchemes: Array<DesRevisionNamingScheme>;
	/** Gets the first allowed naming scheme by the content kind. */
	desRevisionNamingSchemeByContentTypeKind: DesRevisionNamingScheme;
	desSharedWithMe: DesSharedWithMe;
	/** Gets the specified workspace team. */
	desTeam: DesTeam;
	/** Gets the specified workspace users by IDs. */
	desUsers: Array<Maybe<DesUser>>;
	/** Gets the authorized user. */
	desUserByAuth: DesUser;
	/** Gets a user by the specified global ID. */
	desUserByGlobalId?: Maybe<DesUser>;
	/** Search projects within a workspace with results in paged groups. */
	desProjects?: Maybe<DesProjectConnection>;
	/** Search a specific project by its unique identifier. */
	desProjectById?: Maybe<DesProject>;
	/** Gets the unique identifier for a project from its internal identifier. */
	desProjectIdFromAfsId: DesProjectIdPayload;
	desDesignItemById?: Maybe<DesDesignItem>;
	desLibrary: DesLibrary;
	desComponentById?: Maybe<DesComponent>;
	desRevisionDetailsById?: Maybe<DesRevisionDetails>;
	/** Search for comment threads associated with a project. */
	desCommentThreads: Array<DesCommentThread>;
	/** Search for a specific comment thread associated with a project. */
	desCommentThread?: Maybe<DesCommentThread>;
	desReleaseById?: Maybe<DesRelease>;
	/** Gets the BOM by its identifier. */
	desBomById?: Maybe<DesBom>;
	desManufacturePackages: Array<DesManufacturePackage>;
	desManufacturePackageById?: Maybe<DesManufacturePackage>;
	desManufacturePackageCreationJob?: Maybe<DesManufacturePackageCreationJob>;
	/** @deprecated Use `supPartIdFromCiivaId`. */
	supOctopartIdFromCiivaId?: Maybe<Scalars["String"]>;
	/** Nexar infrastructure, subject to change. */
	supPartIdFromCiivaId?: Maybe<Scalars["String"]>;
	/** Nexar infrastructure, subject to change. */
	supCiivaIdFromPartId?: Maybe<Scalars["String"]>;
	/** Nexar infrastructure, subject to change. */
	supPartExtrasByPartId?: Maybe<SupPartExtras>;
	/** Get all attributes */
	supAttributes: Array<SupAttribute>;
	/** Get manufacturer companies */
	supManufacturers: Array<SupCompany>;
	/** Get seller companies (distributors) */
	supSellers: Array<SupCompany>;
	/** Get categories */
	supCategories: Array<SupCategory>;
	/** Get parts by ID. */
	supParts: Array<Maybe<SupPart>>;
	/** Attempt to complete a partial query string.  Used for autosuggest / typeahead text inputs. */
	supSuggest: Array<SupSuggestion>;
	/** Search parts, including filters, pagination, aggregation, sorting */
	supSearch: SupPartResultSet;
	/** Search parts by mpn only, including filters, pagination, aggregation, sorting */
	supSearchMpn: SupPartResultSet;
	/** Suggest an alternate `q` when no results are found */
	supSpellingCorrection: Array<SupSpellingCorrection>;
	/** Match multiple manufacturer + mpn pairs at once.  Useful for when you have a list of parts, as with a BOM (Bill of Materials) */
	supMultiMatch: Array<SupPartMatch>;
	/** get a the quotes from previously submitted metadata */
	manRapidQuotes?: Maybe<ManRapidQuoteResponse>;
	manRapidQuoteRequest?: Maybe<ManRapidQuoteRequest>;
	manOrder?: Maybe<ManOrder>;
	manAssembly?: Maybe<ManAssembly>;
	manListProjectOrders?: Maybe<Array<Maybe<ManOrder>>>;
	manAltimadeLogin?: Maybe<Scalars["String"]>;
	manBomResolution?: Maybe<ManBomResolution>;
	manOrderEventById?: Maybe<ManOrderEvent>;
	/** Get details about the organization(s) the current user belongs to. */
	admOrganizations: Array<AdmOrganization>;
	/** Gets a single application by its unique identifier. */
	admApplicationById?: Maybe<AdmApplication>;
};

export type QueryNodeArgs = {
	id: Scalars["ID"];
};

export type QueryNodesArgs = {
	ids: Array<Scalars["ID"]>;
};

export type QueryDesWorkspacesArgs = {
	where?: Maybe<DesWorkspaceFilterInput>;
};

export type QueryDesWorkspaceByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesSettingsArgs = {
	workspaceUrl: Scalars["String"];
	names: Array<Scalars["String"]>;
};

export type QueryDesLifeCycleDefinitionsArgs = {
	workspaceUrl: Scalars["String"];
};

export type QueryDesLifeCycleDefinitionByContentTypeKindArgs = {
	workspaceUrl: Scalars["String"];
	kind: DesContentTypeKind;
};

export type QueryDesRevisionNamingSchemesArgs = {
	workspaceUrl: Scalars["String"];
};

export type QueryDesRevisionNamingSchemeByContentTypeKindArgs = {
	workspaceUrl: Scalars["String"];
	kind: DesContentTypeKind;
};

export type QueryDesTeamArgs = {
	workspaceUrl: Scalars["String"];
};

export type QueryDesUsersArgs = {
	workspaceUrl: Scalars["String"];
	ids: Array<Scalars["String"]>;
};

export type QueryDesUserByGlobalIdArgs = {
	id: Scalars["String"];
};

export type QueryDesProjectsArgs = {
	workspaceUrl: Scalars["String"];
	first?: Maybe<Scalars["Int"]>;
	after?: Maybe<Scalars["String"]>;
	last?: Maybe<Scalars["Int"]>;
	before?: Maybe<Scalars["String"]>;
	where?: Maybe<DesProjectFilterInput>;
};

export type QueryDesProjectByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesProjectIdFromAfsIdArgs = {
	workspaceUrl: Scalars["String"];
	afsId: Scalars["String"];
	isSharedProject?: Maybe<Scalars["Boolean"]>;
};

export type QueryDesDesignItemByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesLibraryArgs = {
	workspaceUrl: Scalars["String"];
};

export type QueryDesComponentByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesRevisionDetailsByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesCommentThreadsArgs = {
	projectId: Scalars["ID"];
};

export type QueryDesCommentThreadArgs = {
	projectId: Scalars["ID"];
	threadId: Scalars["String"];
};

export type QueryDesReleaseByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesBomByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesManufacturePackageByIdArgs = {
	id: Scalars["ID"];
};

export type QueryDesManufacturePackageCreationJobArgs = {
	id: Scalars["ID"];
};

export type QuerySupOctopartIdFromCiivaIdArgs = {
	workspaceUrl: Scalars["String"];
	ciivaId: Scalars["String"];
};

export type QuerySupPartIdFromCiivaIdArgs = {
	ciivaId: Scalars["String"];
};

export type QuerySupCiivaIdFromPartIdArgs = {
	partId: Scalars["String"];
};

export type QuerySupPartExtrasByPartIdArgs = {
	partId: Scalars["String"];
};

export type QuerySupManufacturersArgs = {
	ids?: Maybe<Array<Scalars["String"]>>;
};

export type QuerySupSellersArgs = {
	ids?: Maybe<Array<Scalars["String"]>>;
};

export type QuerySupCategoriesArgs = {
	ids?: Maybe<Array<Scalars["String"]>>;
	paths?: Maybe<Array<Scalars["String"]>>;
};

export type QuerySupPartsArgs = {
	ids: Array<Scalars["String"]>;
	country?: Scalars["String"];
	currency?: Scalars["String"];
	distributorApi?: Maybe<Scalars["Boolean"]>;
	distributorApiTimeout?: Scalars["String"];
	customPricingCredentials?: Maybe<Array<SupApiCredentials>>;
};

export type QuerySupSuggestArgs = {
	q: Scalars["String"];
	categoryId?: Maybe<Scalars["String"]>;
	partNumbersOnly?: Maybe<Scalars["Boolean"]>;
};

export type QuerySupSearchArgs = {
	q?: Maybe<Scalars["String"]>;
	country?: Scalars["String"];
	currency?: Scalars["String"];
	start?: Maybe<Scalars["Int"]>;
	limit?: Maybe<Scalars["Int"]>;
	sort?: Maybe<Scalars["String"]>;
	sortDir?: Maybe<SupSortDirection>;
	inStockOnly?: Maybe<Scalars["Boolean"]>;
	filters?: Maybe<Scalars["Map"]>;
	distributorApi?: Maybe<Scalars["Boolean"]>;
	distributorApiTimeout?: Scalars["String"];
	customPricingCredentials?: Maybe<Array<SupApiCredentials>>;
};

export type QuerySupSearchMpnArgs = {
	q?: Maybe<Scalars["String"]>;
	country?: Scalars["String"];
	currency?: Scalars["String"];
	start?: Maybe<Scalars["Int"]>;
	limit?: Maybe<Scalars["Int"]>;
	sort?: Maybe<Scalars["String"]>;
	sortDir?: Maybe<SupSortDirection>;
	inStockOnly?: Maybe<Scalars["Boolean"]>;
	filters?: Maybe<Scalars["Map"]>;
	distributorApi?: Maybe<Scalars["Boolean"]>;
	distributorApiTimeout?: Scalars["String"];
	customPricingCredentials?: Maybe<Array<SupApiCredentials>>;
};

export type QuerySupSpellingCorrectionArgs = {
	q: Scalars["String"];
};

export type QuerySupMultiMatchArgs = {
	queries: Array<SupPartMatchQuery>;
	options?: Maybe<SupPartMatchOptions>;
	country?: Scalars["String"];
	currency?: Scalars["String"];
	distributorApi?: Maybe<Scalars["Boolean"]>;
	distributorApiTimeout?: Scalars["String"];
	customPricingCredentials?: Maybe<Array<SupApiCredentials>>;
};

export type QueryManRapidQuotesArgs = {
	id: Scalars["ID"];
};

export type QueryManRapidQuoteRequestArgs = {
	id: Scalars["ID"];
};

export type QueryManOrderArgs = {
	orderId: Scalars["ID"];
};

export type QueryManAssemblyArgs = {
	id: Scalars["ID"];
};

export type QueryManListProjectOrdersArgs = {
	id: Scalars["ID"];
};

export type QueryManAltimadeLoginArgs = {
	gsid?: Maybe<Scalars["ID"]>;
};

export type QueryManBomResolutionArgs = {
	projectId: Scalars["ID"];
	quoteRequestId: Scalars["ID"];
};

export type QueryManOrderEventByIdArgs = {
	id: Scalars["ID"];
};

export type QueryAdmApplicationByIdArgs = {
	id: Scalars["String"];
};

export type Mutation = {
	__typename?: "Mutation";
	desCreateComment: DesCreateCommentPayload;
	desDeleteComment: DesDeleteCommentPayload;
	desUpdateComment: DesUpdateCommentPayload;
	desCreateCommentThread: DesCreateCommentThreadPayload;
	desDeleteCommentThread: DesDeleteCommentThreadPayload;
	/** Releases the specified component. */
	desReleaseComponent: DesReleaseComponentPayload;
	/** Updates parameters for the specified component (creates a new revision). */
	desUpdateComponentRevisionParameters: DesUpdateComponentRevisionParametersPayload;
	/** Uploads the project zip file. */
	desUploadProject: DesUploadProjectPayload;
	/** Creates a user. */
	desCreateUser: DesCreateUserPayload;
	/** Deletes the specified user. */
	desDeleteUser: DesDeleteUserPayload;
	/** Updates the specified user properties. */
	desUpdateUser: DesUpdateUserPayload;
	/** Creates a new user group. */
	desCreateUserGroup: DesCreateUserGroupPayload;
	/** Deletes the specified user group. */
	desDeleteUserGroup: DesDeleteUserGroupPayload;
	/** Updates the specified user group. */
	desUpdateUserGroup: DesUpdateUserGroupPayload;
	/** Adds users to the specified group. */
	desAddUsersToGroup: DesAddUsersToGroupPayload;
	/** Removes users from the specified group. */
	desRemoveUsersFromGroup: DesRemoveUsersFromGroupPayload;
	desLaunchWorkflow: DesLaunchWorkflowPayload;
	desTerminateWorkflows: DesTerminateWorkflowsPayload;
	/** Creates a manufacture package. */
	desCreateManufacturePackage: DesCreateManufacturePackagePayload;
	manCreateRapidQuoteRequest?: Maybe<ManRapidQuoteResponse>;
	/** for a manufacturer to return a rapid quote reponse */
	manRespondRapidQuoteRequest: Scalars["ID"];
	manRespondBulkRapidQuoteRequest: Scalars["ID"];
	manUpdateBomResolution?: Maybe<ManBomResolution>;
	manCreateAssembly?: Maybe<ManCreateAssemblyResponse>;
	manCreateOrder?: Maybe<ManCreateOrderResponse>;
	manUpdateOrderQty?: Maybe<ManOrder>;
	manUpdateOrderShipping?: Maybe<ManOrder>;
	/** accept quote, confirm order as placed. */
	manAcceptOrderQuote?: Maybe<ManOrder>;
	manInsertOrderEvent?: Maybe<ManOrder>;
	manInsertOrderEmsAcceptEvent?: Maybe<ManOrder>;
	manInsertOrderShipUpdateEvent?: Maybe<ManOrder>;
	manInsertOrderReviewEvent?: Maybe<ManOrder>;
	manInsertOrderBatchedEvent?: Maybe<ManOrder>;
	manInsertOrderPartsOrderedEvent?: Maybe<ManOrder>;
	manInsertOrderPcbsOrderedEvent?: Maybe<ManOrder>;
	manInsertOrderPartsReceivedEvent?: Maybe<ManOrder>;
	manInsertOrderPcbsReceivedEvent?: Maybe<ManOrder>;
	manInsertOrderProcessStartEvent?: Maybe<ManOrder>;
	manInsertOrderShippedEvent?: Maybe<ManOrder>;
	manInsertOrderConsignmentDetailsEvent?: Maybe<ManOrder>;
};

export type MutationDesCreateCommentArgs = {
	input: DesCreateCommentInput;
};

export type MutationDesDeleteCommentArgs = {
	input: DesDeleteCommentInput;
};

export type MutationDesUpdateCommentArgs = {
	input: DesUpdateCommentInput;
};

export type MutationDesCreateCommentThreadArgs = {
	input: DesCreateCommentThreadInput;
};

export type MutationDesDeleteCommentThreadArgs = {
	input: DesDeleteCommentThreadInput;
};

export type MutationDesReleaseComponentArgs = {
	input: DesReleaseComponentInput;
};

export type MutationDesUpdateComponentRevisionParametersArgs = {
	input: DesUpdateComponentRevisionParametersInput;
};

export type MutationDesUploadProjectArgs = {
	input: DesUploadProjectInput;
};

export type MutationDesCreateUserArgs = {
	input: DesCreateUserInput;
};

export type MutationDesDeleteUserArgs = {
	input: DesDeleteUserInput;
};

export type MutationDesUpdateUserArgs = {
	input: DesUpdateUserInput;
};

export type MutationDesCreateUserGroupArgs = {
	input: DesCreateUserGroupInput;
};

export type MutationDesDeleteUserGroupArgs = {
	input: DesDeleteUserGroupInput;
};

export type MutationDesUpdateUserGroupArgs = {
	input: DesUpdateUserGroupInput;
};

export type MutationDesAddUsersToGroupArgs = {
	input: DesAddUsersToGroupInput;
};

export type MutationDesRemoveUsersFromGroupArgs = {
	input: DesRemoveUsersFromGroupInput;
};

export type MutationDesLaunchWorkflowArgs = {
	input: DesLaunchWorkflowInput;
};

export type MutationDesTerminateWorkflowsArgs = {
	input: DesTerminateWorkflowsInput;
};

export type MutationDesCreateManufacturePackageArgs = {
	input: DesCreateManufacturePackageInput;
};

export type MutationManCreateRapidQuoteRequestArgs = {
	qty: Scalars["Int"];
	meta: ManBoardMetaInput;
	shipping?: Maybe<ManShippingDetailsInput>;
};

export type MutationManRespondRapidQuoteRequestArgs = {
	id: Scalars["ID"];
	quote: ManQuoteInput;
};

export type MutationManRespondBulkRapidQuoteRequestArgs = {
	id: Scalars["ID"];
	quotes: Array<ManQuoteInput>;
};

export type MutationManUpdateBomResolutionArgs = {
	projectId: Scalars["ID"];
	quoteRequestId: Scalars["ID"];
	newSelections?: Maybe<Array<ManPartSelectionInput>>;
};

export type MutationManCreateAssemblyArgs = {
	quoteRequest: Scalars["ID"];
	commitId?: Maybe<Scalars["ID"]>;
	projectId: Scalars["ID"];
};

export type MutationManCreateOrderArgs = {
	qty?: Maybe<Scalars["Int"]>;
	assemblyId: Scalars["ID"];
};

export type MutationManUpdateOrderQtyArgs = {
	orderId: Scalars["ID"];
	qty: Scalars["Int"];
};

export type MutationManUpdateOrderShippingArgs = {
	orderId: Scalars["ID"];
	shipping: ManShippingDetailsInput;
};

export type MutationManAcceptOrderQuoteArgs = {
	orderId: Scalars["ID"];
	quoteId: Scalars["ID"];
};

export type MutationManInsertOrderEventArgs = {
	id: Scalars["ID"];
	event?: Maybe<ManOrderEventType>;
	attributes?: Maybe<Scalars["String"]>;
};

export type MutationManInsertOrderEmsAcceptEventArgs = {
	input: ManOrderEmsAcceptInput;
};

export type MutationManInsertOrderShipUpdateEventArgs = {
	input: ManOrderShipEstimateInput;
};

export type MutationManInsertOrderReviewEventArgs = {
	input: ManOrderReviewInput;
};

export type MutationManInsertOrderBatchedEventArgs = {
	input: ManOrderBatchedInput;
};

export type MutationManInsertOrderPartsOrderedEventArgs = {
	input: ManOrderPartsOrderedInput;
};

export type MutationManInsertOrderPcbsOrderedEventArgs = {
	input: ManOrderPcbsOrderedInput;
};

export type MutationManInsertOrderPartsReceivedEventArgs = {
	input: ManOrderPartsReceivedInput;
};

export type MutationManInsertOrderPcbsReceivedEventArgs = {
	input: ManOrderPcbsReceivedInput;
};

export type MutationManInsertOrderProcessStartEventArgs = {
	input: ManOrderProcessStartInput;
};

export type MutationManInsertOrderShippedEventArgs = {
	input: ManOrderShippedInput;
};

export type MutationManInsertOrderConsignmentDetailsEventArgs = {
	input: ManOrderConsignmentDetailsInput;
};

export type Subscription = {
	__typename?: "Subscription";
	desOnCommentUpdated: DesCommentNotification;
};

export type SubscriptionDesOnCommentUpdatedArgs = {
	input: DesOnCommentUpdatedInput;
};

/** The node interface is implemented by entities that have a global unique identifier. */
export type Node = {
	id: Scalars["ID"];
};

export type DesAddUsersToGroupPayload = {
	__typename?: "DesAddUsersToGroupPayload";
	errors: Array<DesPayloadError>;
};

export type DesArea = {
	__typename?: "DesArea";
	x: Scalars["Float"];
	xMm2: Scalars["Decimal"];
	xMils2: Scalars["Decimal"];
};

export type DesAssemblyDrawings = {
	__typename?: "DesAssemblyDrawings";
	assemblyDrawingFiles: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

/** A Bill of Materials (BOM) contains a list of all of the parts needed for the assembly of a PCB. */
export type DesBom = Node & {
	__typename?: "DesBom";
	/** The node identifier for this BOM (used by `desBomById`). */
	id: Scalars["ID"];
	/** The list of each unique part within the BOM. */
	bomItems: Array<DesBomItem>;
};

/** A Bill of Materials (BOM) item contains usage information for a unique component on the PCB. */
export type DesBomItem = {
	__typename?: "DesBomItem";
	/** The detailed component infomation for this BOM item. */
	component?: Maybe<DesComponent>;
	/** The total number of times this item is used. */
	quantity: Scalars["Decimal"];
	/** The list of each instance of this BOM item. */
	bomItemInstances: Array<DesBomItemInstance>;
};

/** A Bill of Materials (BOM) item instance contains infomation for one specific use case of the item. */
export type DesBomItemInstance = {
	__typename?: "DesBomItemInstance";
	/** The unique label for this item. */
	designator: Scalars["String"];
	/** The variant use status for this item. */
	isFitted: Scalars["Boolean"];
};

/** A comment is one of a collection of remarks associated with a comment thread. */
export type DesComment = {
	__typename?: "DesComment";
	/** The account information for who created this comment. */
	createdBy: DesUser;
	/** The account information for who most recently modified this comment. */
	modifiedBy: DesUser;
	/** The account information for those who are referenced for this comment. */
	mentions: Array<DesMention>;
	/** The reference identifier for this comment (use with desDeleteComment). */
	commentId: Scalars["String"];
	/** The content body of this comment. */
	text: Scalars["String"];
	/** The `DateTime` for the creation of this comment. */
	createdAt: Scalars["DateTime"];
	/** The `DateTime` for the most recent modification of this comment. */
	modifiedAt: Scalars["DateTime"];
};

/** A comment context provides additional information about associations for a comment thread. */
export type DesCommentContext = {
	__typename?: "DesCommentContext";
	/** The reference identifier for the document associated with a comment thread. */
	documentId?: Maybe<Scalars["String"]>;
	/** The reference identifier for an object associated with a comment thread. */
	objectId?: Maybe<Scalars["String"]>;
	/** The area associated with a comment thread. */
	area: DesRectangle;
	/** The release identifier associated with a comment thread. */
	releaseId?: Maybe<Scalars["String"]>;
};

export type DesCommentNotification = {
	__typename?: "DesCommentNotification";
	action: Scalars["String"];
	data: DesCommentNotificationData;
};

export type DesCommentNotificationData = {
	__typename?: "DesCommentNotificationData";
	projectId: Scalars["String"];
	documentId?: Maybe<Scalars["String"]>;
	documentName?: Maybe<Scalars["String"]>;
	commentThreadId: Scalars["String"];
	threadDate: Scalars["String"];
	threadData?: Maybe<Scalars["String"]>;
	threadStatus?: Maybe<Scalars["String"]>;
	commentId: Scalars["String"];
	commentAuthor?: Maybe<Scalars["String"]>;
	commentDate: Scalars["String"];
	commentText?: Maybe<Scalars["String"]>;
};

/** A comment thread contains an initial remark associated with the design and a collection of replies. */
export type DesCommentThread = {
	__typename?: "DesCommentThread";
	/** The account information for the owner of any action or response to this comment thread. */
	assignedTo?: Maybe<DesUser>;
	/** The account information for who created this comment thread. */
	createdBy: DesUser;
	/** The account information for who most recently modified this comment thread. */
	modifiedBy: DesUser;
	/** The list of replies associated with this comment thread. */
	comments: Array<DesComment>;
	/** The reference identifier for this comment thread (used by `desCreateComment` and `desDeleteComment`). */
	commentThreadId: Scalars["String"];
	status: Scalars["Int"];
	/** The `DateTime` for the creation of this comment thread. */
	createdAt: Scalars["DateTime"];
	/** The `DateTime` for the most recent modification of this comment thread. */
	modifiedAt: Scalars["DateTime"];
	/** The web address to download the screenshot associated with the creation of this comment thread. */
	originalStateScreenshotUrl?: Maybe<Scalars["String"]>;
	/** The sequence number of this comment thread. */
	threadNumber: Scalars["Int"];
	/** The information about properties related to this comment thread. */
	context: DesCommentContext;
};

/** A component contains the parametric details of a part attached the PCB. */
export type DesComponent = Node & {
	__typename?: "DesComponent";
	/** The node identifier for this component (used by `desComponentById`). */
	id: Scalars["ID"];
	/** The component folder. */
	folder?: Maybe<DesFolder>;
	/** The list of the part choices associated with this component. */
	manufacturerParts: Array<DesManufacturerPart>;
	/** More component data, relatively expensive, recommended for individual components with `desComponentById`. */
	details: DesComponentDetails;
	/** The library label for this component. */
	name: Scalars["String"];
	/** The additional information for this component. */
	comment: Scalars["String"];
	/** The summary of function or other performance details for this component. */
	description: Scalars["String"];
	/** The component revision. */
	revision: DesRevision;
	model3D?: Maybe<DesModel3D>;
};

/** A connection to a list of items. */
export type DesComponentConnection = {
	__typename?: "DesComponentConnection";
	/** Information to aid in pagination. */
	pageInfo: PageInfo;
	/** A list of edges. */
	edges?: Maybe<Array<DesComponentEdge>>;
	/** A flattened list of the nodes. */
	nodes?: Maybe<Array<DesComponent>>;
	totalCount: Scalars["Int"];
};

export type DesComponentDetails = {
	__typename?: "DesComponentDetails";
	/** The list of the parameters describing this component. */
	parameters: Array<DesComponentParameter>;
	/** The list of the symbols used for this component. */
	symbols: Array<DesSymbol>;
	/** The list of the footprints used this component. */
	footprints: Array<DesFootprint>;
};

/** An edge in a connection. */
export type DesComponentEdge = {
	__typename?: "DesComponentEdge";
	/** A cursor for use in pagination. */
	cursor: Scalars["String"];
	/** The item at the end of the edge. */
	node: DesComponent;
};

export type DesComponentParameter = {
	__typename?: "DesComponentParameter";
	type: DesParameterType;
	name: Scalars["String"];
	value: Scalars["String"];
};

export type DesCreateCommentPayload = {
	__typename?: "DesCreateCommentPayload";
	commentId: Scalars["String"];
	errors: Array<DesPayloadError>;
};

export type DesCreateCommentThreadPayload = {
	__typename?: "DesCreateCommentThreadPayload";
	commentThreadId: Scalars["String"];
	commentId: Scalars["String"];
	errors: Array<DesPayloadError>;
};

export type DesCreateManufacturePackagePayload = {
	__typename?: "DesCreateManufacturePackagePayload";
	jobId: Scalars["ID"];
	errors: Array<DesPayloadError>;
};

export type DesCreateUserGroupPayload = {
	__typename?: "DesCreateUserGroupPayload";
	id: Scalars["ID"];
};

export type DesCreateUserPayload = {
	__typename?: "DesCreateUserPayload";
	userId: Scalars["String"];
};

export type DesDeleteCommentPayload = {
	__typename?: "DesDeleteCommentPayload";
	errors: Array<DesPayloadError>;
};

export type DesDeleteCommentThreadPayload = {
	__typename?: "DesDeleteCommentThreadPayload";
	errors: Array<DesPayloadError>;
};

export type DesDeleteUserGroupPayload = {
	__typename?: "DesDeleteUserGroupPayload";
	errors: Array<DesPayloadError>;
};

export type DesDeleteUserPayload = {
	__typename?: "DesDeleteUserPayload";
	errors: Array<DesPayloadError>;
};

/** A design manages all of the schematic, PCB, and BOM content for a project. */
export type DesDesign = {
	__typename?: "DesDesign";
	/** The list of published versions of the design grouped into pages. */
	releases?: Maybe<DesReleaseConnection>;
	/** The most recent version of the design. */
	workInProgress: DesWorkInProgress;
};

/** A design manages all of the schematic, PCB, and BOM content for a project. */
export type DesDesignReleasesArgs = {
	first?: Maybe<Scalars["Int"]>;
	after?: Maybe<Scalars["String"]>;
	last?: Maybe<Scalars["Int"]>;
	before?: Maybe<Scalars["String"]>;
	where?: Maybe<DesReleaseFilterInput>;
};

export type DesDesignExchange = {
	__typename?: "DesDesignExchange";
	models3D: Array<DesModel3D>;
	downloadableFile: DesDownloadableFile;
};

/** A design item is a specific instance of a part used in the design. */
export type DesDesignItem = Node & {
	__typename?: "DesDesignItem";
	/** The node identifier for this project (used by `DesDesignItemById`). */
	id: Scalars["ID"];
	/** The detailed component infomation for this design item. */
	component?: Maybe<DesComponent>;
	/** The list of all comment threads related to this design item. */
	commentThreads?: Maybe<Array<DesCommentThread>>;
	/** The unique label for this design item. */
	designator: Scalars["String"];
	/** The summary of function or other performance details for this design item. */
	description: Scalars["String"];
	/** The additional information for this design item. */
	comment: Scalars["String"];
	/** The layer(side) placement for this design item. */
	layer?: Maybe<DesLayer>;
	/** The planar location for this design item. */
	position: DesPosition2D;
	/** The planar boundary for this design item. */
	area?: Maybe<DesRectangle>;
	footprintName: Scalars["String"];
	/** The rotation in degrees. */
	rotation?: Maybe<Scalars["Decimal"]>;
	/** The list of connection targets for this design item. */
	pads: Array<DesPad>;
	/** The list of multiple layer connections for this design item. */
	vias: Array<DesVia>;
	/** The list of conductor segments for this design item. */
	tracks: Array<DesTrack>;
};

/** A connection to a list of items. */
export type DesDesignItemConnection = {
	__typename?: "DesDesignItemConnection";
	/** Information to aid in pagination. */
	pageInfo: PageInfo;
	/** A list of edges. */
	edges?: Maybe<Array<DesDesignItemEdge>>;
	/** A flattened list of the nodes. */
	nodes?: Maybe<Array<DesDesignItem>>;
	totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type DesDesignItemEdge = {
	__typename?: "DesDesignItemEdge";
	/** A cursor for use in pagination. */
	cursor: Scalars["String"];
	/** The item at the end of the edge. */
	node: DesDesignItem;
};

export type DesDownloadableFile = {
	__typename?: "DesDownloadableFile";
	fileName: Scalars["String"];
	relativePath: Scalars["String"];
	downloadUrl: Scalars["String"];
};

export type DesFolder = {
	__typename?: "DesFolder";
	name: Scalars["String"];
	description: Scalars["String"];
};

export type DesFootprint = {
	__typename?: "DesFootprint";
	imageFullSizeUrl: Scalars["String"];
	imageThumbnailUrl: Scalars["String"];
	dataDownloadUrl: Scalars["String"];
	pins: Array<DesPin>;
	folder?: Maybe<DesFolder>;
	guid: Scalars["String"];
	name: Scalars["String"];
	comment: Scalars["String"];
	description: Scalars["String"];
};

export type DesGerber = {
	__typename?: "DesGerber";
	gerberFiles: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

export type DesGerberX2 = {
	__typename?: "DesGerberX2";
	gerberX2Files: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

export type DesIpc2581 = {
	__typename?: "DesIpc2581";
	ipc2581Files: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

export type DesLaunchWorkflowPayload = {
	__typename?: "DesLaunchWorkflowPayload";
	id: Scalars["String"];
	status: Scalars["Int"];
};

export type DesLayer = {
	__typename?: "DesLayer";
	name: Scalars["String"];
	thickness?: Maybe<DesSize>;
	dielectricConstant?: Maybe<Scalars["Decimal"]>;
	copperWeight?: Maybe<DesWeight>;
	/** The copper area. */
	copperArea?: Maybe<DesArea>;
	/** The ratio of copper area to PCB area. */
	copperRatio?: Maybe<Scalars["Decimal"]>;
	material?: Maybe<Scalars["String"]>;
	nets: Array<DesNet>;
	layerType: DesLayerType;
	layerProperties: Array<DesLayerProperty>;
};

export type DesLayerProperty = {
	__typename?: "DesLayerProperty";
	name: Scalars["String"];
	text: Scalars["String"];
	size?: Maybe<DesSize>;
};

export type DesLibrary = {
	__typename?: "DesLibrary";
	/** Gets library components. */
	components?: Maybe<DesComponentConnection>;
};

export type DesLibraryComponentsArgs = {
	first?: Maybe<Scalars["Int"]>;
	after?: Maybe<Scalars["String"]>;
	last?: Maybe<Scalars["Int"]>;
	before?: Maybe<Scalars["String"]>;
	where?: Maybe<DesComponentFilterInput>;
};

/** Revision naming scheme details obtained by `desLibrary/lifeCycleDefinitions`. */
export type DesLifeCycleDefinition = {
	__typename?: "DesLifeCycleDefinition";
	lifeCycleDefinitionId: Scalars["String"];
	name: Scalars["String"];
};

export type DesLifeCycleState = {
	__typename?: "DesLifeCycleState";
	name: Scalars["String"];
};

export type DesManufacturePackage = Node & {
	__typename?: "DesManufacturePackage";
	/** The node identifier for this project (used by `desManufacturePackageById`). */
	id: Scalars["ID"];
	name: Scalars["String"];
	downloadUrl: Scalars["String"];
};

export type DesManufacturePackageCreationJob = {
	__typename?: "DesManufacturePackageCreationJob";
	id: Scalars["String"];
	createdAt: Scalars["DateTime"];
	payload: DesManufacturePackageCreationJobPayload;
	status: DesJobStatus;
};

export type DesManufacturePackageCreationJobPayload = {
	__typename?: "DesManufacturePackageCreationJobPayload";
	packageId?: Maybe<Scalars["ID"]>;
	errors: Array<DesPayloadError>;
};

export type DesManufacturerPart = {
	__typename?: "DesManufacturerPart";
	supplierParts: Array<DesSupplierPart>;
	/** The Octopart ID. */
	octopartId?: Maybe<Scalars["String"]>;
	/** The manufacturer company name. */
	companyName: Scalars["String"];
	/** The part number (MPN). */
	partNumber: Scalars["String"];
	priority: Scalars["Int"];
};

export type DesMention = {
	__typename?: "DesMention";
	user: DesUser;
	type: Scalars["Int"];
};

export type DesModel3D = {
	__typename?: "DesModel3D";
	parasolidFile: DesDownloadableFile;
};

export type DesNcDrill = {
	__typename?: "DesNcDrill";
	ncDrillFiles: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

export type DesNet = {
	__typename?: "DesNet";
	name: Scalars["String"];
	cumulativeLength: DesSize;
	layers: Array<DesLayer>;
	pads: Array<DesPad>;
	vias: Array<DesVia>;
	tracks: Array<DesTrack>;
};

export type DesOdb = {
	__typename?: "DesOdb";
	odbFiles: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

export type DesPad = {
	__typename?: "DesPad";
	padType: DesPadType;
	layer?: Maybe<DesLayer>;
	net?: Maybe<DesNet>;
	designator?: Maybe<Scalars["String"]>;
	globalDesignator?: Maybe<Scalars["String"]>;
	radius?: Maybe<Scalars["Int"]>;
	rotation?: Maybe<Scalars["Decimal"]>;
	isPlated?: Maybe<Scalars["Boolean"]>;
	holeSize: DesSize;
	size: DesSize2D;
	shape?: Maybe<DesPrimitiveShape>;
	position: DesPosition2D;
};

export type DesPayloadError = {
	__typename?: "DesPayloadError";
	message: Scalars["String"];
};

/** A PCB contains design details of the physical product. */
export type DesPcb = {
	__typename?: "DesPcb";
	/** The details of the layer structure of this PCB. */
	layerStack?: Maybe<DesStackup>;
	/** The outline of this PCB. */
	outline: DesPolygon;
	/** The list of all part instances used in this PCB grouped into pages. */
	designItems?: Maybe<DesDesignItemConnection>;
	/** The list of all electrically connected regions in this PCB. */
	nets: Array<DesNet>;
	/** The list of all part connection targets in this PCB. */
	pads: Array<DesPad>;
	/** The list of all conductor segments in this PCB. */
	tracks: Array<DesTrack>;
	/** The list of all multiple layer connections in this PCB. */
	vias: Array<DesVia>;
	/** The list of all comment threads related to this PCB. */
	commentThreads: Array<DesCommentThread>;
	/** The reference identifier for this PCB. */
	documentId: Scalars["String"];
	/** The dimensions of the PCB outline. */
	size: DesSize2D;
	/** The total area contained by the PCB outline. */
	area: DesArea;
	/** The location of the coordinate system origin relative to ???. */
	origin: DesPosition2D;
};

/** A PCB contains design details of the physical product. */
export type DesPcbDesignItemsArgs = {
	designators?: Maybe<Array<Scalars["String"]>>;
	first?: Maybe<Scalars["Int"]>;
	after?: Maybe<Scalars["String"]>;
	last?: Maybe<Scalars["Int"]>;
	before?: Maybe<Scalars["String"]>;
};

/** A PCB contains design details of the physical product. */
export type DesPcbNetsArgs = {
	names?: Maybe<Array<Scalars["String"]>>;
};

export type DesPcbAssembly = {
	__typename?: "DesPcbAssembly";
	packageName: Scalars["String"];
	pickAndPlace: DesPickAndPlace;
	assemblyDrawings: DesAssemblyDrawings;
	downloadUrl: Scalars["String"];
};

export type DesPcbFabrication = {
	__typename?: "DesPcbFabrication";
	packageName: Scalars["String"];
	odb: DesOdb;
	ipc2581: DesIpc2581;
	gerber: DesGerber;
	gerberX2: DesGerberX2;
	ncDrill: DesNcDrill;
	testPoints: DesTestPoints;
	downloadUrl: Scalars["String"];
};

export type DesPickAndPlace = {
	__typename?: "DesPickAndPlace";
	pickAndPlaceFiles: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

export type DesPin = {
	__typename?: "DesPin";
	name: Scalars["String"];
};

export type DesPolygon = {
	__typename?: "DesPolygon";
	vertices: Array<DesPosition2D>;
};

export type DesPosition2D = {
	__typename?: "DesPosition2D";
	xMm: Scalars["Decimal"];
	yMm: Scalars["Decimal"];
	xMils: Scalars["Decimal"];
	yMils: Scalars["Decimal"];
	x: Scalars["Int"];
	y: Scalars["Int"];
};

/** A project manages all development stages of the PCB/PCA product lifecycle. */
export type DesProject = Node & {
	__typename?: "DesProject";
	/** The node identifier for this project (used by `desProjectById`). */
	id: Scalars["ID"];
	/** The account information for who created this project. */
	createdBy?: Maybe<DesUser>;
	/** The account information for who last modified this project. */
	updatedBy?: Maybe<DesUser>;
	/** The list of the parameters describing this project. */
	parameters: Array<DesProjectParameter>;
	/** The web address to download a preview image for this project. */
	previewUrl: Scalars["String"];
	/** The list of workflows associated with this project. */
	workflows?: Maybe<Array<DesWorkflow>>;
	/** The Altium 365 web address. */
	url: Scalars["String"];
	/** The reference identifier for this project. */
	projectId: Scalars["String"];
	/** The assigned name for this project. */
	name?: Maybe<Scalars["String"]>;
	/** The summary of this project content or purpose. */
	description?: Maybe<Scalars["String"]>;
	/** The `DateTime` when this project was created. */
	createdAt?: Maybe<Scalars["DateTime"]>;
	/** The `DateTime` when this project was last modified. */
	updatedAt?: Maybe<Scalars["DateTime"]>;
	/** The detailed design information for this project. */
	design: DesDesign;
};

/** A project manages all development stages of the PCB/PCA product lifecycle. */
export type DesProjectParametersArgs = {
	names?: Maybe<Array<Scalars["String"]>>;
};

/** A project manages all development stages of the PCB/PCA product lifecycle. */
export type DesProjectWorkflowsArgs = {
	isClosed?: Scalars["Boolean"];
	modifiedAfter?: Maybe<Scalars["DateTime"]>;
	where?: Maybe<DesWorkflowFilterInput>;
};

/** A connection to a list of items. */
export type DesProjectConnection = {
	__typename?: "DesProjectConnection";
	/** Information to aid in pagination. */
	pageInfo: PageInfo;
	/** A list of edges. */
	edges?: Maybe<Array<DesProjectEdge>>;
	/** A flattened list of the nodes. */
	nodes?: Maybe<Array<DesProject>>;
	totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type DesProjectEdge = {
	__typename?: "DesProjectEdge";
	/** A cursor for use in pagination. */
	cursor: Scalars["String"];
	/** The item at the end of the edge. */
	node: DesProject;
};

export type DesProjectIdPayload = {
	__typename?: "DesProjectIdPayload";
	id: Scalars["ID"];
};

export type DesProjectParameter = {
	__typename?: "DesProjectParameter";
	name: Scalars["String"];
	value: Scalars["String"];
};

export type DesRectangle = {
	__typename?: "DesRectangle";
	pos1: DesPosition2D;
	pos2: DesPosition2D;
};

/** A release is a published version of a design with additional generated files for manufacturing. */
export type DesRelease = Node & {
	__typename?: "DesRelease";
	/** The node identifier for this release (used by `desReleaseById`). */
	id: Scalars["ID"];
	/** The list of variations contained in this release. */
	variants: Array<DesReleaseVariant>;
	manufacturePackages: Array<DesManufacturePackage>;
	/** The `DateTime` when this release was created. */
	createdAt: Scalars["DateTime"];
	/** The summary of this release content or purpose. */
	description: Scalars["String"];
	/** The reference identifier for this release. */
	releaseId: Scalars["String"];
};

/** A release is a published version of a design with additional generated files for manufacturing. */
export type DesReleaseVariantsArgs = {
	where?: Maybe<DesReleaseVariantFilterInput>;
};

export type DesReleaseComponentPayload = {
	__typename?: "DesReleaseComponentPayload";
	errors: Array<DesPayloadError>;
};

/** A connection to a list of items. */
export type DesReleaseConnection = {
	__typename?: "DesReleaseConnection";
	/** Information to aid in pagination. */
	pageInfo: PageInfo;
	/** A list of edges. */
	edges?: Maybe<Array<DesReleaseEdge>>;
	/** A flattened list of the nodes. */
	nodes?: Maybe<Array<DesRelease>>;
	totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type DesReleaseEdge = {
	__typename?: "DesReleaseEdge";
	/** A cursor for use in pagination. */
	cursor: Scalars["String"];
	/** The item at the end of the edge. */
	node: DesRelease;
};

/** A variant contains a specific configuration of a base design. */
export type DesReleaseVariant = {
	__typename?: "DesReleaseVariant";
	/** The data needed for assembly of this published design variant. */
	pcbAssembly?: Maybe<DesPcbAssembly>;
	/** The data needed for fabrication of this published design variant. */
	pcbFabrication?: Maybe<DesPcbFabrication>;
	/** The Bill of Materials (BOM) for this published design variant. */
	bom?: Maybe<DesBom>;
	/** The PCB document for this design variant. */
	pcb?: Maybe<DesPcb>;
	/** The descriptive label for this design variant. */
	name: Scalars["String"];
	/** The list of schematic documents for this design variant. */
	schematics: Array<DesSchematic>;
};

export type DesRemoveUsersFromGroupPayload = {
	__typename?: "DesRemoveUsersFromGroupPayload";
	errors: Array<DesPayloadError>;
};

/** Revision details ID for later use or full details. */
export type DesRevision = {
	__typename?: "DesRevision";
	/** The full revision details. */
	details: DesRevisionDetails;
	/** The revision details node ID for later use. */
	id: Scalars["ID"];
};

/** Revision details. */
export type DesRevisionDetails = {
	__typename?: "DesRevisionDetails";
	lifeCycleState: DesLifeCycleState;
	childCount: Scalars["Int"];
	references: Array<DesDownloadableFile>;
	parentCount: Scalars["Int"];
	/** The node ID. */
	id: Scalars["ID"];
	description?: Maybe<Scalars["String"]>;
	comment?: Maybe<Scalars["String"]>;
};

/** Revision naming scheme details obtained by `desLibrary/revisionNamingSchemes`. */
export type DesRevisionNamingScheme = {
	__typename?: "DesRevisionNamingScheme";
	revisionNamingSchemeId: Scalars["String"];
	name: Scalars["String"];
};

/** A schematic contains the design parts and logical connections. */
export type DesSchematic = {
	__typename?: "DesSchematic";
	/** The list of all part instances used in this schematic grouped into pages. */
	designItems?: Maybe<DesDesignItemConnection>;
	/** The list of all logical part connections in this schematic. */
	nets: Array<DesNet>;
	/** The list of all comment threads related to this schematic. */
	commentThreads: Array<DesCommentThread>;
	/** The reference identifier for this schematic. */
	documentId: Scalars["String"];
	parentIds: Array<Scalars["String"]>;
	units: Scalars["Int"];
};

/** A schematic contains the design parts and logical connections. */
export type DesSchematicDesignItemsArgs = {
	first?: Maybe<Scalars["Int"]>;
	after?: Maybe<Scalars["String"]>;
	last?: Maybe<Scalars["Int"]>;
	before?: Maybe<Scalars["String"]>;
};

/** A schematic contains the design parts and logical connections. */
export type DesSchematicNetsArgs = {
	names?: Maybe<Array<Scalars["String"]>>;
};

export type DesSharedWithMe = {
	__typename?: "DesSharedWithMe";
	projects: Array<DesProject>;
	manufacturePackages: Array<DesManufacturePackage>;
	commentThreads: Array<DesCommentThread>;
};

export type DesSize = {
	__typename?: "DesSize";
	x: Scalars["Decimal"];
	xMm: Scalars["Decimal"];
	xMils: Scalars["Decimal"];
};

export type DesSize2D = {
	__typename?: "DesSize2D";
	x: Scalars["Int"];
	y: Scalars["Int"];
	xMm: Scalars["Decimal"];
	xMils: Scalars["Decimal"];
	yMm: Scalars["Decimal"];
	yMils: Scalars["Decimal"];
};

export type DesStack = {
	__typename?: "DesStack";
	name: Scalars["String"];
	layers: Array<DesLayer>;
};

export type DesStackup = {
	__typename?: "DesStackup";
	stackupType: Scalars["String"];
	layerTypes: Array<DesLayerType>;
	roughnessType: Scalars["String"];
	roughnessFactorSR: Scalars["String"];
	roughnessFactorRF: Scalars["String"];
	stacks: Array<DesStack>;
};

export type DesSupplierPart = {
	__typename?: "DesSupplierPart";
	/** The supplier company name. */
	companyName: Scalars["String"];
	/** The part number (SKU). */
	partNumber: Scalars["String"];
	/** Available for library components. */
	prices?: Maybe<Array<DesSupplierPrice>>;
	/** Available for library components. */
	stocks?: Maybe<Array<DesSupplierStock>>;
};

export type DesSupplierPrice = {
	__typename?: "DesSupplierPrice";
	currency: Scalars["String"];
	price: Scalars["Decimal"];
	breakQuantity: Scalars["Int"];
};

export type DesSupplierStock = {
	__typename?: "DesSupplierStock";
	locationName: Scalars["String"];
	quantity: Scalars["Decimal"];
};

export type DesSymbol = {
	__typename?: "DesSymbol";
	imageFullSizeUrl: Scalars["String"];
	imageThumbnailUrl: Scalars["String"];
	dataDownloadUrl: Scalars["String"];
	pins: Array<DesPin>;
	folder?: Maybe<DesFolder>;
	guid: Scalars["String"];
	name: Scalars["String"];
	comment: Scalars["String"];
	description: Scalars["String"];
};

export type DesTeam = {
	__typename?: "DesTeam";
	users: Array<DesUser>;
	groups: Array<DesUserGroup>;
};

export type DesTerminateWorkflowsError = {
	__typename?: "DesTerminateWorkflowsError";
	id: Scalars["String"];
	message: Scalars["String"];
};

export type DesTerminateWorkflowsPayload = {
	__typename?: "DesTerminateWorkflowsPayload";
	errors: Array<DesTerminateWorkflowsError>;
};

export type DesTestPoints = {
	__typename?: "DesTestPoints";
	testPointFiles: Array<DesDownloadableFile>;
	packageName?: Maybe<Scalars["String"]>;
	downloadUrl?: Maybe<Scalars["String"]>;
};

export type DesTrack = {
	__typename?: "DesTrack";
	layer?: Maybe<DesLayer>;
	net?: Maybe<DesNet>;
	width: DesSize;
	begin: DesPosition2D;
	end: DesPosition2D;
};

export type DesUpdateCommentPayload = {
	__typename?: "DesUpdateCommentPayload";
	errors: Array<DesPayloadError>;
};

export type DesUpdateComponentRevisionParametersPayload = {
	__typename?: "DesUpdateComponentRevisionParametersPayload";
	componentId: Scalars["ID"];
	errors: Array<DesPayloadError>;
};

export type DesUpdateUserGroupPayload = {
	__typename?: "DesUpdateUserGroupPayload";
	errors: Array<DesPayloadError>;
};

export type DesUpdateUserPayload = {
	__typename?: "DesUpdateUserPayload";
	errors: Array<DesPayloadError>;
};

export type DesUploadProjectPayload = {
	__typename?: "DesUploadProjectPayload";
	/** The project ID. */
	projectId: Scalars["ID"];
	errors: Array<DesPayloadError>;
};

/** User details with the identifier and nullable extra fields. */
export type DesUser = {
	__typename?: "DesUser";
	/** Null if the user no longer exists. */
	pictureUrl?: Maybe<Scalars["String"]>;
	/** Null if the user no longer exists. */
	groups?: Maybe<Array<DesUserGroup>>;
	/** The internal user ID. */
	userId: Scalars["String"];
	/** Null if the user no longer exists. */
	userName?: Maybe<Scalars["String"]>;
	/** Null if the user no longer exists. */
	email?: Maybe<Scalars["String"]>;
	/** Null if the user no longer exists. */
	firstName?: Maybe<Scalars["String"]>;
	/** Null if the user no longer exists. */
	lastName?: Maybe<Scalars["String"]>;
};

/** User details with the identifier and nullable extra fields. */
export type DesUserPictureUrlArgs = {
	size?: Maybe<DesUserPictureSize>;
};

/** A user group information. */
export type DesUserGroup = Node & {
	__typename?: "DesUserGroup";
	/** The node ID. */
	id: Scalars["ID"];
	/** The group name. */
	name: Scalars["String"];
};

export type DesVia = {
	__typename?: "DesVia";
	layer?: Maybe<DesLayer>;
	net?: Maybe<DesNet>;
	beginLayer?: Maybe<DesLayer>;
	endLayer?: Maybe<DesLayer>;
	name?: Maybe<Scalars["String"]>;
	holeDiameter: DesSize;
	padDiameter: DesSize;
	shape?: Maybe<DesPrimitiveShape>;
	position: DesPosition2D;
};

export type DesWeight = {
	__typename?: "DesWeight";
	x: Scalars["Decimal"];
	gram: Scalars["Decimal"];
	ounce: Scalars["Decimal"];
};

/** A variant contains a specific configuration of a base design. */
export type DesWipVariant = {
	__typename?: "DesWipVariant";
	designExchange?: Maybe<DesDesignExchange>;
	/** The Bill of Materials (BOM) for this design variant. */
	bom?: Maybe<DesBom>;
	/** The PCB document for this design variant. */
	pcb?: Maybe<DesPcb>;
	/** The descriptive label for this design variant. */
	name: Scalars["String"];
	/** The list of schematic documents for this design variant. */
	schematics: Array<DesSchematic>;
};

/** The most recent version of a design. */
export type DesWorkInProgress = {
	__typename?: "DesWorkInProgress";
	/** The list of variations contained in this design. */
	variants: Array<DesWipVariant>;
};

/** The most recent version of a design. */
export type DesWorkInProgressVariantsArgs = {
	where?: Maybe<DesWipVariantFilterInput>;
};

/** A workflow manages the execution of a logical sequence of tasks. */
export type DesWorkflow = {
	__typename?: "DesWorkflow";
	/** The list of variables defined for this workflow. */
	variables: Array<DesWorkflowVariable>;
	/** The `DateTime` for the most recent changes for this workflow. */
	modifiedAt: Scalars["DateTime"];
	/** The reference identifier for this workflow. */
	workflowId: Scalars["String"];
	/** The name of the active task(s) for this workflow. */
	state?: Maybe<Scalars["String"]>;
	/** The account information for the owner of any action or response needed for this workflow. */
	assignee: Scalars["String"];
	/** The account information for who created this workflow. */
	createdBy: Scalars["String"];
	/** The `DateTime` for the creation of this workflow. */
	createdAt: Scalars["DateTime"];
	/** The `DateTime` for the completion of this workflow. */
	endedAt?: Maybe<Scalars["DateTime"]>;
	/** The label for this workflow. */
	name: Scalars["String"];
	/** The reference identifier for definition of this workflow. */
	processDefinitionId: Scalars["String"];
	/** The label for the definition of this workflow. */
	processDefinitionName: Scalars["String"];
	/** The current condition of this workflow. */
	status: Scalars["String"];
};

/** A workflow manages the execution of a logical sequence of tasks. */
export type DesWorkflowVariablesArgs = {
	names?: Maybe<Array<Scalars["String"]>>;
};

/** A workflow definition contains a logical sequence of tasks. */
export type DesWorkflowDefinition = {
	__typename?: "DesWorkflowDefinition";
	/** The list of variables need to launch this workflow definition. */
	variables: Array<DesWorkflowVariable>;
	/** The reference identifier for this workflow definition. */
	workflowDefinitionId: Scalars["String"];
	/** The label for this workflow definition. */
	name: Scalars["String"];
	/** The account information for who created this workflow definition. */
	createdBy: Scalars["String"];
	/** The `DateTime` for the creation of this workflow definition. */
	createdAt: Scalars["DateTime"];
};

export type DesWorkflowVariable = {
	__typename?: "DesWorkflowVariable";
	valueType?: Maybe<Scalars["String"]>;
	constraint?: Maybe<Scalars["String"]>;
	name: Scalars["String"];
	value: Scalars["String"];
};

/** A workspace provides a flexible and secure method for managing design, manufacturing and supply content. */
export type DesWorkspace = Node & {
	__typename?: "DesWorkspace";
	/** The node identifier for the workspace (used by `DesWorkspaceById`). */
	id: Scalars["ID"];
	/** The location of this workspace. */
	location: DesWorkspaceLocation;
	/** The resource managing components for this workspace. */
	library: DesLibrary;
	/** The list of members authorized for this workspace. */
	team: DesTeam;
	/** The list of projects managed in this workspace. */
	projects: Array<DesProject>;
	/** The list of workflow definitions in this workspace. */
	workflowDefinitions?: Maybe<Array<DesWorkflowDefinition>>;
	/** The list of workflows in this workspace. */
	workflows?: Maybe<Array<DesWorkflow>>;
	/** The descriptive label for this workspace. */
	name: Scalars["String"];
	/** The web address of this workspace. */
	url: Scalars["String"];
	/** The summary of this workspace content or purpose. */
	description?: Maybe<Scalars["String"]>;
	/** Tells if the workspace is the current user default. */
	isDefault: Scalars["Boolean"];
};

/** A workspace provides a flexible and secure method for managing design, manufacturing and supply content. */
export type DesWorkspaceProjectsArgs = {
	where?: Maybe<DesProjectFilterInput>;
};

/** A workspace provides a flexible and secure method for managing design, manufacturing and supply content. */
export type DesWorkspaceWorkflowDefinitionsArgs = {
	where?: Maybe<DesWorkflowDefinitionFilterInput>;
};

/** A workspace provides a flexible and secure method for managing design, manufacturing and supply content. */
export type DesWorkspaceWorkflowsArgs = {
	where?: Maybe<DesWorkflowFilterInput>;
};

export type DesWorkspaceLocation = {
	__typename?: "DesWorkspaceLocation";
	/** The name of the location. */
	name: Scalars["String"];
	/** The preferred Nexar API URL to use for this location. */
	apiServiceUrl: Scalars["String"];
	/** The preferred files service URL to use for this location. */
	filesServiceUrl: Scalars["String"];
};

/** Information about pagination in a connection. */
export type PageInfo = {
	__typename?: "PageInfo";
	/** Indicates whether more edges exist following the set defined by the clients arguments. */
	hasNextPage: Scalars["Boolean"];
	/** Indicates whether more edges exist prior the set defined by the clients arguments. */
	hasPreviousPage: Scalars["Boolean"];
	/** When paginating backwards, the cursor to continue. */
	startCursor?: Maybe<Scalars["String"]>;
	/** When paginating forwards, the cursor to continue. */
	endCursor?: Maybe<Scalars["String"]>;
};

export type SupPartExtras = {
	__typename?: "SupPartExtras";
	alternatives: Array<SupPartExtras>;
	partId: Scalars["String"];
	description?: Maybe<Scalars["String"]>;
	isRohsCompliant?: Maybe<Scalars["Boolean"]>;
	datasheetUrls?: Maybe<Array<Scalars["String"]>>;
	lifeCycle: SupPartLifeCycle;
	parameters?: Maybe<Array<SupPartExtrasParameter>>;
	technicalDetails?: Maybe<Array<SupPartExtrasTechnicalDetail>>;
};

export type SupPartExtrasAlternativesArgs = {
	first?: Scalars["Int"];
};

export type SupPartExtrasParameter = {
	__typename?: "SupPartExtrasParameter";
	name: Scalars["String"];
	unit?: Maybe<Scalars["String"]>;
	value?: Maybe<Array<Scalars["String"]>>;
};

export type SupPartExtrasTechnicalDetail = {
	__typename?: "SupPartExtrasTechnicalDetail";
	name: Scalars["String"];
	value: Scalars["String"];
};

export type BooleanOperationFilterInput = {
	eq?: Maybe<Scalars["Boolean"]>;
	neq?: Maybe<Scalars["Boolean"]>;
};

export type ComparableDateTimeOperationFilterInput = {
	eq?: Maybe<Scalars["DateTime"]>;
	neq?: Maybe<Scalars["DateTime"]>;
	in?: Maybe<Array<Scalars["DateTime"]>>;
	nin?: Maybe<Array<Scalars["DateTime"]>>;
	gt?: Maybe<Scalars["DateTime"]>;
	ngt?: Maybe<Scalars["DateTime"]>;
	gte?: Maybe<Scalars["DateTime"]>;
	ngte?: Maybe<Scalars["DateTime"]>;
	lt?: Maybe<Scalars["DateTime"]>;
	nlt?: Maybe<Scalars["DateTime"]>;
	lte?: Maybe<Scalars["DateTime"]>;
	nlte?: Maybe<Scalars["DateTime"]>;
};

export type ComparableInt32OperationFilterInput = {
	eq?: Maybe<Scalars["Int"]>;
	neq?: Maybe<Scalars["Int"]>;
	in?: Maybe<Array<Scalars["Int"]>>;
	nin?: Maybe<Array<Scalars["Int"]>>;
	gt?: Maybe<Scalars["Int"]>;
	ngt?: Maybe<Scalars["Int"]>;
	gte?: Maybe<Scalars["Int"]>;
	ngte?: Maybe<Scalars["Int"]>;
	lt?: Maybe<Scalars["Int"]>;
	nlt?: Maybe<Scalars["Int"]>;
	lte?: Maybe<Scalars["Int"]>;
	nlte?: Maybe<Scalars["Int"]>;
};

export type ComparableNullableOfDateTimeOperationFilterInput = {
	eq?: Maybe<Scalars["DateTime"]>;
	neq?: Maybe<Scalars["DateTime"]>;
	in?: Maybe<Array<Maybe<Scalars["DateTime"]>>>;
	nin?: Maybe<Array<Maybe<Scalars["DateTime"]>>>;
	gt?: Maybe<Scalars["DateTime"]>;
	ngt?: Maybe<Scalars["DateTime"]>;
	gte?: Maybe<Scalars["DateTime"]>;
	ngte?: Maybe<Scalars["DateTime"]>;
	lt?: Maybe<Scalars["DateTime"]>;
	nlt?: Maybe<Scalars["DateTime"]>;
	lte?: Maybe<Scalars["DateTime"]>;
	nlte?: Maybe<Scalars["DateTime"]>;
};

export type DesAddUsersToGroupInput = {
	/** The group node ID. */
	id: Scalars["ID"];
	/** User IDs. */
	userIds: Array<Scalars["String"]>;
};

/** A component contains the parametric details of a part attached the PCB. */
export type DesComponentFilterInput = {
	and?: Maybe<Array<DesComponentFilterInput>>;
	or?: Maybe<Array<DesComponentFilterInput>>;
	/** The library label for this component. */
	name?: Maybe<StringOperationFilterInput>;
	/** The additional information for this component. */
	comment?: Maybe<StringOperationFilterInput>;
	/** The summary of function or other performance details for this component. */
	description?: Maybe<StringOperationFilterInput>;
	/** The component revision. */
	revision?: Maybe<DesRevisionFilterInput>;
};

export type DesCreateCommentInput = {
	entityId: Scalars["ID"];
	commentThreadId: Scalars["String"];
	text: Scalars["String"];
};

export type DesCreateCommentThreadInput = {
	entityId: Scalars["ID"];
	documentId: Scalars["String"];
	text: Scalars["String"];
	objectId?: Maybe<Scalars["String"]>;
	area?: Maybe<DesRectangleInput>;
	releaseId?: Maybe<Scalars["String"]>;
};

export type DesCreateManufacturePackageInput = {
	/** The ID of the project to create a manufacture package from. */
	projectId: Scalars["ID"];
	/** The Git commit which determines the version of the project to use. If not provided, the latest version is used. */
	vcsRevisionId?: Maybe<Scalars["String"]>;
	/** The name for the package. */
	name: Scalars["String"];
	/** A description for the package. */
	description?: Maybe<Scalars["String"]>;
	/** The email addresses of the manufacturers to share the package with. */
	shareWith: Array<Scalars["String"]>;
	/** The project variant to use when creating the package. If not provided, the default variant is used. */
	variantName?: Maybe<Scalars["String"]>;
	/** A webhook URL that will receive a POST request when the manufacture package has been created and shared. */
	callbackUrl?: Maybe<Scalars["String"]>;
};

export type DesCreateUserGroupInput = {
	workspaceUrl: Scalars["String"];
	name: Scalars["String"];
};

export type DesCreateUserInput = {
	workspaceUrl: Scalars["String"];
	userName: Scalars["String"];
	password: Scalars["String"];
	firstName: Scalars["String"];
	lastName: Scalars["String"];
	email: Scalars["String"];
};

export type DesDeleteCommentInput = {
	entityId: Scalars["ID"];
	commentThreadId: Scalars["String"];
	commentId: Scalars["String"];
};

export type DesDeleteCommentThreadInput = {
	entityId: Scalars["ID"];
	commentThreadId: Scalars["String"];
};

export type DesDeleteUserGroupInput = {
	/** The group node ID. */
	id: Scalars["ID"];
};

export type DesDeleteUserInput = {
	workspaceUrl: Scalars["String"];
	userId: Scalars["String"];
};

export type DesLaunchWorkflowInput = {
	workspaceUrl: Scalars["String"];
	workflowDefinitionId: Scalars["String"];
	name?: Maybe<Scalars["String"]>;
	/** The string variables. */
	variables: Array<DesWorkflowVariableInput>;
	/** The attachment variables. */
	attachments?: Maybe<Array<DesWorkflowAttachmentVariableInput>>;
};

export type DesOnCommentUpdatedInput = {
	workspaceUrl: Scalars["String"];
	token: Scalars["String"];
};

export type DesPosition2DInput = {
	x: Scalars["Int"];
	y: Scalars["Int"];
};

/** A project manages all development stages of the PCB/PCA product lifecycle. */
export type DesProjectFilterInput = {
	and?: Maybe<Array<DesProjectFilterInput>>;
	or?: Maybe<Array<DesProjectFilterInput>>;
	/** The Altium 365 web address. */
	url?: Maybe<StringOperationFilterInput>;
	/** The reference identifier for this project. */
	projectId?: Maybe<StringOperationFilterInput>;
	/** The assigned name for this project. */
	name?: Maybe<StringOperationFilterInput>;
	/** The summary of this project content or purpose. */
	description?: Maybe<StringOperationFilterInput>;
	/** The `DateTime` when this project was created. */
	createdAt?: Maybe<ComparableNullableOfDateTimeOperationFilterInput>;
	/** The `DateTime` when this project was last modified. */
	updatedAt?: Maybe<ComparableNullableOfDateTimeOperationFilterInput>;
};

export type DesRectangleInput = {
	pos1: DesPosition2DInput;
	pos2: DesPosition2DInput;
};

export type DesReleaseComponentFileInput = {
	/** Uploaded file ID. */
	fileId: Scalars["String"];
	/** Relative path of the source file. */
	relativePath: Scalars["String"];
};

export type DesReleaseComponentInput = {
	workspaceUrl: Scalars["String"];
	componentReleaseFolder: Scalars["String"];
	componentItemName: Scalars["String"];
	componentRevisionNamingSchemeId?: Maybe<Scalars["String"]>;
	componentLifeCycleDefinitionId?: Maybe<Scalars["String"]>;
	componentComment?: Maybe<Scalars["String"]>;
	componentDescription?: Maybe<Scalars["String"]>;
	parameters: Array<DesRevisionParameterInput>;
	/** The symbol folder path, existing or to be created. */
	symbolReleaseFolder: Scalars["String"];
	/** The symbol name. Use null to be generated. */
	symbolItemName?: Maybe<Scalars["String"]>;
	symbolFiles: Array<DesReleaseComponentFileInput>;
	symbolRevisionNamingSchemeId?: Maybe<Scalars["String"]>;
	symbolLifeCycleDefinitionId?: Maybe<Scalars["String"]>;
	/** The footprint folder path, existing or to be created. */
	footprintReleaseFolder: Scalars["String"];
	/** The footprint name. Use null to be generated. */
	footprintItemName?: Maybe<Scalars["String"]>;
	footprintFiles: Array<DesReleaseComponentFileInput>;
	footprintRevisionNamingSchemeId?: Maybe<Scalars["String"]>;
	footprintLifeCycleDefinitionId?: Maybe<Scalars["String"]>;
};

/** A release is a published version of a design with additional generated files for manufacturing. */
export type DesReleaseFilterInput = {
	and?: Maybe<Array<DesReleaseFilterInput>>;
	or?: Maybe<Array<DesReleaseFilterInput>>;
	/** The node identifier for this release (used by `desReleaseById`). */
	id?: Maybe<StringOperationFilterInput>;
	/** The `DateTime` when this release was created. */
	createdAt?: Maybe<ComparableDateTimeOperationFilterInput>;
	/** The summary of this release content or purpose. */
	description?: Maybe<StringOperationFilterInput>;
	/** The reference identifier for this release. */
	releaseId?: Maybe<StringOperationFilterInput>;
};

/** A variant contains a specific configuration of a base design. */
export type DesReleaseVariantFilterInput = {
	and?: Maybe<Array<DesReleaseVariantFilterInput>>;
	or?: Maybe<Array<DesReleaseVariantFilterInput>>;
	/** The descriptive label for this design variant. */
	name?: Maybe<StringOperationFilterInput>;
	/** The list of schematic documents for this design variant. */
	schematics?: Maybe<ListFilterInputTypeOfDesSchematicFilterInput>;
};

export type DesRemoveUsersFromGroupInput = {
	/** The group node ID. */
	id: Scalars["ID"];
	/** User IDs. */
	userIds: Array<Scalars["String"]>;
};

/** Revision details ID for later use or full details. */
export type DesRevisionFilterInput = {
	and?: Maybe<Array<DesRevisionFilterInput>>;
	or?: Maybe<Array<DesRevisionFilterInput>>;
	/** The revision details node ID for later use. */
	id?: Maybe<IdOperationFilterInput>;
};

export type DesRevisionParameterInput = {
	name: Scalars["String"];
	value: Scalars["String"];
};

/** A schematic contains the design parts and logical connections. */
export type DesSchematicFilterInput = {
	and?: Maybe<Array<DesSchematicFilterInput>>;
	or?: Maybe<Array<DesSchematicFilterInput>>;
	/** The reference identifier for this schematic. */
	documentId?: Maybe<StringOperationFilterInput>;
	parentIds?: Maybe<ListStringOperationFilterInput>;
	units?: Maybe<ComparableInt32OperationFilterInput>;
};

export type DesTerminateWorkflowsInput = {
	workspaceUrl: Scalars["String"];
	workflowIds: Array<Scalars["String"]>;
};

export type DesUpdateCommentInput = {
	entityId: Scalars["ID"];
	commentThreadId: Scalars["String"];
	commentId: Scalars["String"];
	text: Scalars["String"];
};

export type DesUpdateComponentRevisionParametersInput = {
	componentId: Scalars["ID"];
	componentRevisionNamingSchemeId?: Maybe<Scalars["String"]>;
	releaseNote?: Maybe<Scalars["String"]>;
	/** Tells to replace all existing parameters. By default parameters are added to existing. */
	replaceExisting?: Maybe<Scalars["Boolean"]>;
	parameters: Array<DesRevisionParameterInput>;
};

export type DesUpdateUserGroupInput = {
	/** The group node ID. */
	id: Scalars["ID"];
	/** The group name. */
	name: Scalars["String"];
};

export type DesUpdateUserInput = {
	workspaceUrl: Scalars["String"];
	userId: Scalars["String"];
	firstName?: Maybe<Scalars["String"]>;
	lastName?: Maybe<Scalars["String"]>;
};

export type DesUploadProjectInput = {
	/** The workspace URL. */
	workspaceUrl: Scalars["String"];
	/** The uploaded zip file ID. */
	fileId: Scalars["String"];
	/** The project name. */
	name: Scalars["String"];
	/** The project description. */
	description?: Maybe<Scalars["String"]>;
	/** The project target folder path. */
	folderPath?: Maybe<Scalars["String"]>;
};

/** A variant contains a specific configuration of a base design. */
export type DesWipVariantFilterInput = {
	and?: Maybe<Array<DesWipVariantFilterInput>>;
	or?: Maybe<Array<DesWipVariantFilterInput>>;
	/** The descriptive label for this design variant. */
	name?: Maybe<StringOperationFilterInput>;
	/** The list of schematic documents for this design variant. */
	schematics?: Maybe<ListFilterInputTypeOfDesSchematicFilterInput>;
};

export type DesWorkflowAttachmentVariableInput = {
	/** The variable name. */
	name: Scalars["String"];
	/** Uploaded file references. */
	files: Array<Scalars["String"]>;
};

/** A workflow definition contains a logical sequence of tasks. */
export type DesWorkflowDefinitionFilterInput = {
	and?: Maybe<Array<DesWorkflowDefinitionFilterInput>>;
	or?: Maybe<Array<DesWorkflowDefinitionFilterInput>>;
	/** The reference identifier for this workflow definition. */
	workflowDefinitionId?: Maybe<StringOperationFilterInput>;
	/** The label for this workflow definition. */
	name?: Maybe<StringOperationFilterInput>;
	/** The account information for who created this workflow definition. */
	createdBy?: Maybe<StringOperationFilterInput>;
	/** The `DateTime` for the creation of this workflow definition. */
	createdAt?: Maybe<ComparableDateTimeOperationFilterInput>;
};

/** A workflow manages the execution of a logical sequence of tasks. */
export type DesWorkflowFilterInput = {
	and?: Maybe<Array<DesWorkflowFilterInput>>;
	or?: Maybe<Array<DesWorkflowFilterInput>>;
	/** The reference identifier for this workflow. */
	workflowId?: Maybe<StringOperationFilterInput>;
	/** The name of the active task(s) for this workflow. */
	state?: Maybe<StringOperationFilterInput>;
	/** The account information for the owner of any action or response needed for this workflow. */
	assignee?: Maybe<StringOperationFilterInput>;
	/** The account information for who created this workflow. */
	createdBy?: Maybe<StringOperationFilterInput>;
	/** The `DateTime` for the creation of this workflow. */
	createdAt?: Maybe<ComparableDateTimeOperationFilterInput>;
	/** The `DateTime` for the completion of this workflow. */
	endedAt?: Maybe<ComparableNullableOfDateTimeOperationFilterInput>;
	/** The label for this workflow. */
	name?: Maybe<StringOperationFilterInput>;
	/** The reference identifier for definition of this workflow. */
	processDefinitionId?: Maybe<StringOperationFilterInput>;
	/** The label for the definition of this workflow. */
	processDefinitionName?: Maybe<StringOperationFilterInput>;
	/** The current condition of this workflow. */
	status?: Maybe<StringOperationFilterInput>;
};

export type DesWorkflowVariableInput = {
	valueType?: Maybe<Scalars["String"]>;
	constraint?: Maybe<Scalars["String"]>;
	name: Scalars["String"];
	value: Scalars["String"];
};

/** A workspace provides a flexible and secure method for managing design, manufacturing and supply content. */
export type DesWorkspaceFilterInput = {
	and?: Maybe<Array<DesWorkspaceFilterInput>>;
	or?: Maybe<Array<DesWorkspaceFilterInput>>;
	/** The node identifier for the workspace (used by `DesWorkspaceById`). */
	id?: Maybe<StringOperationFilterInput>;
	/** The descriptive label for this workspace. */
	name?: Maybe<StringOperationFilterInput>;
	/** The web address of this workspace. */
	url?: Maybe<StringOperationFilterInput>;
	/** The summary of this workspace content or purpose. */
	description?: Maybe<StringOperationFilterInput>;
	/** Tells if the workspace is the current user default. */
	isDefault?: Maybe<BooleanOperationFilterInput>;
};

export type IdOperationFilterInput = {
	eq?: Maybe<Scalars["ID"]>;
	neq?: Maybe<Scalars["ID"]>;
	in?: Maybe<Array<Maybe<Scalars["ID"]>>>;
	nin?: Maybe<Array<Maybe<Scalars["ID"]>>>;
};

export type ListFilterInputTypeOfDesSchematicFilterInput = {
	all?: Maybe<DesSchematicFilterInput>;
	none?: Maybe<DesSchematicFilterInput>;
	some?: Maybe<DesSchematicFilterInput>;
	any?: Maybe<Scalars["Boolean"]>;
};

export type ListStringOperationFilterInput = {
	all?: Maybe<StringOperationFilterInput>;
	none?: Maybe<StringOperationFilterInput>;
	some?: Maybe<StringOperationFilterInput>;
	any?: Maybe<Scalars["Boolean"]>;
};

export type StringOperationFilterInput = {
	and?: Maybe<Array<StringOperationFilterInput>>;
	or?: Maybe<Array<StringOperationFilterInput>>;
	eq?: Maybe<Scalars["String"]>;
	neq?: Maybe<Scalars["String"]>;
	contains?: Maybe<Scalars["String"]>;
	ncontains?: Maybe<Scalars["String"]>;
	in?: Maybe<Array<Maybe<Scalars["String"]>>>;
	nin?: Maybe<Array<Maybe<Scalars["String"]>>>;
	startsWith?: Maybe<Scalars["String"]>;
	nstartsWith?: Maybe<Scalars["String"]>;
	endsWith?: Maybe<Scalars["String"]>;
	nendsWith?: Maybe<Scalars["String"]>;
};

export enum DesContentTypeKind {
	Component = "COMPONENT",
	EmbeddedDesign = "EMBEDDED_DESIGN",
	FpgaDesign = "FPGA_DESIGN",
	OpenBus = "OPEN_BUS",
	PartChoiceList = "PART_CHOICE_LIST",
	PcbComponent = "PCB_COMPONENT",
	PcbDesign = "PCB_DESIGN",
	PcbDocument = "PCB_DOCUMENT",
	PcbBlank = "PCB_BLANK",
	PcbAssembly = "PCB_ASSEMBLY",
	PcbModel3D = "PCB_MODEL3D",
	SchematicSheet = "SCHEMATIC_SHEET",
	SchematicTemplate = "SCHEMATIC_TEMPLATE",
	SimulationModel = "SIMULATION_MODEL",
	SiModel = "SI_MODEL",
	Symbol = "SYMBOL",
	OutputJob = "OUTPUT_JOB",
	MorfikPackage = "MORFIK_PACKAGE",
	MorfikWebResource = "MORFIK_WEB_RESOURCE",
	MorfikXAppDesign = "MORFIK_X_APP_DESIGN",
	MorfikXAppImage = "MORFIK_X_APP_IMAGE",
	MorfikXAppSet = "MORFIK_X_APP_SET",
	WebItem = "WEB_ITEM",
	DxpAddon = "DXP_ADDON",
	DataClass = "DATA_CLASS",
	DeviceClass = "DEVICE_CLASS",
	RichText = "RICH_TEXT",
	Preferences = "PREFERENCES",
	Model3D = "MODEL3D",
	ComponentTemplate = "COMPONENT_TEMPLATE",
	LayerStack = "LAYER_STACK",
	BomTemplate = "BOM_TEMPLATE",
	Script = "SCRIPT",
	Project = "PROJECT",
	ProjectTemplate = "PROJECT_TEMPLATE",
	DataSheet = "DATA_SHEET",
	DraftsmanDocumentTemplate = "DRAFTSMAN_DOCUMENT_TEMPLATE",
	DraftsmanSheetTemplate = "DRAFTSMAN_SHEET_TEMPLATE",
	ProjectReviewPackage = "PROJECT_REVIEW_PACKAGE",
	PlmInstance = "PLM_INSTANCE",
	PlmPublishTemplate = "PLM_PUBLISH_TEMPLATE",
	PcbBlock = "PCB_BLOCK",
	BinaryFile = "BINARY_FILE",
	DxpPlatform = "DXP_PLATFORM",
	DxpSdk = "DXP_SDK",
	DxpPlugin = "DXP_PLUGIN",
	BmsAutoGeneratedComponents = "BMS_AUTO_GENERATED_COMPONENTS"
}

export enum DesJobStatus {
	Pending = "PENDING",
	Processing = "PROCESSING",
	Done = "DONE",
	Error = "ERROR"
}

export enum DesLayerType {
	Abstract = "ABSTRACT",
	Unknown = "UNKNOWN",
	Physical = "PHYSICAL",
	Dielectric = "DIELECTRIC",
	Overlay = "OVERLAY",
	SolderMask = "SOLDER_MASK",
	BikiniCoverlay = "BIKINI_COVERLAY",
	PasteMask = "PASTE_MASK",
	Mechanical = "MECHANICAL",
	Foil = "FOIL",
	Plane = "PLANE",
	Signal = "SIGNAL",
	SurfaceFinish = "SURFACE_FINISH",
	Core = "CORE",
	Prepreg = "PREPREG",
	Plating = "PLATING",
	Adhesive = "ADHESIVE",
	Stiffener = "STIFFENER",
	Misc = "MISC",
	PeLayer = "PE_LAYER",
	Conductive = "CONDUCTIVE",
	NonConductive = "NON_CONDUCTIVE"
}

export enum DesPadType {
	Smd = "SMD",
	Free = "FREE"
}

export enum DesParameterType {
	None = "NONE",
	Text = "TEXT",
	Voltage = "VOLTAGE",
	Current = "CURRENT",
	Resistance = "RESISTANCE",
	Conductance = "CONDUCTANCE",
	Capacitance = "CAPACITANCE",
	Charge = "CHARGE",
	Inductance = "INDUCTANCE",
	Power = "POWER",
	Impedance = "IMPEDANCE",
	Frequency = "FREQUENCY",
	Temperature = "TEMPERATURE",
	Decibels = "DECIBELS",
	Percent = "PERCENT",
	Length = "LENGTH",
	Mass = "MASS",
	Time = "TIME"
}

export enum DesPrimitiveShape {
	Round = "ROUND",
	Rectangle = "RECTANGLE",
	RoundedRectangle = "ROUNDED_RECTANGLE"
}

export enum DesUserPictureSize {
	Size48X48 = "SIZE48X48",
	Size70X70 = "SIZE70X70",
	Size128X128 = "SIZE128X128",
	Original = "ORIGINAL"
}

export enum SupPartLifeCycle {
	Unknown = "UNKNOWN",
	New = "NEW",
	Active = "ACTIVE",
	Nrfnd = "NRFND",
	Eol = "EOL",
	Discontinued = "DISCONTINUED",
	ActiveUnconfirmed = "ACTIVE_UNCONFIRMED",
	DiscontinuedUnconfirmed = "DISCONTINUED_UNCONFIRMED",
	ContactMfr = "CONTACT_MFR",
	Transferred = "TRANSFERRED"
}

/** Used to show the filters that are applied to current search. */
export type SupAppliedFilter = {
	__typename?: "SupAppliedFilter";
	/** shortname is the key in the filters Map.  Usually an attribute shortname, or `manufacturerId`, `distributorId`, etc. */
	shortname: Scalars["String"];
	/** human readable name to display in the UI */
	name: Scalars["String"];
	/** values in the filter Map. */
	values: Array<Scalars["String"]>;
	/** human readable values to display in the UI */
	displayValues: Array<Scalars["String"]>;
};

/** Defines an attribute like Capacitance or Resistance. */
export type SupAttribute = {
	__typename?: "SupAttribute";
	/** Internal Octopart ID */
	id: Scalars["ID"];
	/** display name */
	name: Scalars["String"];
	/** use as key for `sort` or `filter` in part search */
	shortname: Scalars["String"];
	/** use to group together similar attributes, e.g. Technical, Physical, Compliance */
	group: Scalars["String"];
};

/** Groups similar attributes together, as can be seen with column groups in specs view */
export type SupAttributeGroup = {
	__typename?: "SupAttributeGroup";
	/** Name of group, e.g. Technical, Physical, Compliance */
	name: Scalars["String"];
	/** Attributes in group */
	attributes: Array<SupAttribute>;
};

/** Information for use on /electronic-parts Category pages. */
export type SupBlurb = {
	__typename?: "SupBlurb";
	/** Category name. */
	name: Scalars["String"];
	/** Path to /electronic-parts Category page. */
	pathName: Scalars["String"];
	/** Short description of Category. */
	description: Scalars["String"];
	/** Longer description of Category. */
	content: Scalars["String"];
};

/** cadAgg produces a CadBucket with the count of parts that have CAD Symbol + Footprint and 3D model */
export type SupCadBucket = {
	__typename?: "SupCadBucket";
	cadState: Scalars["String"];
	count?: Maybe<Scalars["Int"]>;
};

/**
 * A Category exists in a Category tree.  Examples include Passive Components or Capacitors.  The `path` field is helpful to see where a category is in the tree.
 * Category id `4161` is the root of tree.
 */
export type SupCategory = {
	__typename?: "SupCategory";
	/** Octopart internal id.  Root id is 4161 */
	id: Scalars["ID"];
	/** ID of parent category. */
	parentId: Scalars["ID"];
	/** Display name */
	name: Scalars["String"];
	/** List of all ancestor in category tree. */
	ancestors: Array<SupCategory>;
	/** List of direct children in category tree. */
	children: Array<SupCategory>;
	/** Slash separated path.  Can be used to visit URL for category page.  (e.g. `/electronic-parts/circuit-protection/esd-and-circuit-protection-ics`) */
	path: Scalars["String"];
	/** List of Attributes deemed to be relevant to this category.  (e.g. Resistance for Resistor category).  Useful for showing contextual filters in UI. */
	relevantAttributes: Array<SupAttribute>;
	/** Blurb for Category, used on /electronic-parts pages. */
	blurb?: Maybe<SupBlurb>;
	/** Number of parts in Category. */
	numParts: Scalars["Int"];
};

/** categoryAgg produces a CategoryBucket with category + counts */
export type SupCategoryBucket = {
	__typename?: "SupCategoryBucket";
	category: SupCategory;
	count?: Maybe<Scalars["Int"]>;
};

/** A company record represents a manufacturer or distributor, depending on context. */
export type SupCompany = {
	__typename?: "SupCompany";
	/** Octopart internal id */
	id: Scalars["ID"];
	/** Display name of company */
	name: Scalars["String"];
	/** Aliases of company */
	aliases: Array<Scalars["String"]>;
	/** The country code for the display flag */
	displayFlag?: Maybe<Scalars["String"]>;
	/** Homepage URL of company */
	homepageUrl?: Maybe<Scalars["String"]>;
	/** Used for URLs like `/manufacturers/aimtec` or `/distributors/digi-key` */
	slug: Scalars["String"];
	/** True if a manufacturer participates in Octopart's Verified Manufacturer program.  See [verified](https://octopart.com/verified) for more information. */
	isVerified: Scalars["Boolean"];
	/**
	 * True if a distributor is a broker.  See [authorized](https://octopart.com/authorized) for more information.
	 * @deprecated use `PartSeller.is_broker` instead
	 */
	isBroker: Scalars["Boolean"];
	/** True if a distributor has an API integration with Octopart to provide latest pricing and stock data. */
	isDistributorApi: Scalars["Boolean"];
};

/** manufacturerAgg and distributorAgg produce a CompanyBucket with company + counts */
export type SupCompanyBucket = {
	__typename?: "SupCompanyBucket";
	company: SupCompany;
	count?: Maybe<Scalars["Int"]>;
};

/** A country's name, country code, and continent code. */
export type SupCountry = {
	__typename?: "SupCountry";
	name: Scalars["String"];
	countryCode: Scalars["String"];
	continentCode: Scalars["String"];
};

/** Textual description of a part */
export type SupDescription = {
	__typename?: "SupDescription";
	/** Description text */
	text: Scalars["String"];
	/** Source of description.  Used for attribution. */
	creditString: Scalars["String"];
	/** Source URL of description.  Used for attribution. */
	creditUrl: Scalars["String"];
};

/** Document represents a PDF file and can be a Datasheet, Compliance Document, PCN, etc. */
export type SupDocument = {
	__typename?: "SupDocument";
	name: Scalars["String"];
	pageCount?: Maybe<Scalars["Int"]>;
	createdAt?: Maybe<Scalars["Time"]>;
	url: Scalars["String"];
	creditString: Scalars["String"];
	creditUrl: Scalars["String"];
	mimeType: Scalars["String"];
};

/** DocumentCollection groups documents together by type: Datasheets, Compliance Statements. */
export type SupDocumentCollection = {
	__typename?: "SupDocumentCollection";
	/** Name of group, e.g. Datasheets */
	name: Scalars["String"];
	/** List of Documents in group */
	documents: Array<SupDocument>;
};

/** Image of a part.  In the case of some symbol and footprint images, the scaled version may not actually be scaled and cropped, and may need to be scaled using CSS or other techniques. */
export type SupImage = {
	__typename?: "SupImage";
	/** @deprecated use `url` instead */
	urlLargest: Scalars["String"];
	/** @deprecated use `url` instead */
	url55px: Scalars["String"];
	/** @deprecated use `url` instead */
	url75px: Scalars["String"];
	/** @deprecated use `url` instead */
	url90px: Scalars["String"];
	/** Image URL */
	url: Scalars["String"];
	/** Source of description.  Used for attribution. */
	creditString: Scalars["String"];
	/** Source URL of description.  Used for attribution. */
	creditUrl: Scalars["String"];
};

/** An offer is a specific buyable part from a distributor, with specific packaging, pricing, stock, moq. */
export type SupOffer = {
	__typename?: "SupOffer";
	/** Cache ID */
	_cacheId: Scalars["String"];
	/** Octopart internal ID for this offer */
	id: Scalars["ID"];
	/** Stock Keeping Unit used by internally by distributor */
	sku: Scalars["String"];
	/** The code indicating the region(s) for which offer is valid */
	eligibleRegion?: Maybe<Scalars["String"]>;
	/** Number of units available to be shipped.  (aka Stock, Quantity) */
	inventoryLevel: Scalars["Int"];
	/** Packaging of parts (eg Tape, Reel) */
	packaging?: Maybe<Scalars["String"]>;
	/** Minimum Order Quantity: smallest number of parts that can be purchased */
	moq?: Maybe<Scalars["Int"]>;
	prices: Array<SupPricePoint>;
	/** The URL to view offer on distributor website.  This will redirect via Octopart's server. */
	clickUrl: Scalars["String"];
	/** Octopart internal URL for this offer. */
	internalUrl: Scalars["String"];
	/** The last time data was received from distributor feed or API for this offer. */
	updated: Scalars["Time"];
	/** Number of days to acquire parts from factory. */
	factoryLeadDays?: Maybe<Scalars["Int"]>;
	/** Number of parts on order from factory. */
	onOrderQuantity?: Maybe<Scalars["Int"]>;
	/** Order multiple for factory orders. */
	factoryPackQuantity?: Maybe<Scalars["Int"]>;
	/** Number of items which must be ordered together. */
	orderMultiple?: Maybe<Scalars["Int"]>;
	/** The quantity of parts as packaged by the seller. */
	multipackQuantity?: Maybe<Scalars["Int"]>;
	/** Whether this offer is specific to the customer making the request. */
	isCustomPricing: Scalars["Boolean"];
};

/** Part model contains the relevant data around a part, including: datasheets, specs, sellers + offers, images, etc. */
export type SupPart = {
	__typename?: "SupPart";
	/** Cache ID */
	_cacheId: Scalars["String"];
	/** Octopart internal ID for this part.  Appears at the end of PDP URL / `slug` field. */
	id: Scalars["ID"];
	/** manufacturer + mpn for easy display */
	name: Scalars["String"];
	/** Manufacturer Part Number */
	mpn: Scalars["String"];
	/** Best guess at a generic MPN */
	genericMpn: Scalars["String"];
	/** Company that manufactures this part */
	manufacturer: SupCompany;
	/** A link to the manufacturer detail page for this part or series. */
	manufacturerUrl?: Maybe<Scalars["String"]>;
	/** A link to a manufacturer page to request free sample kits for this part. */
	freeSampleUrl?: Maybe<Scalars["String"]>;
	/** Documents including Datasheets, Compliance Documents, PCNs */
	documentCollections: Array<SupDocumentCollection>;
	/** Best description around 110 characters long, as can be seen on SERP or PDP.  May need truncation if all descriptions are long. */
	shortDescription: Scalars["String"];
	/** All part descriptions from sources */
	descriptions: Array<SupDescription>;
	/** All part images */
	images: Array<SupImage>;
	/** Attribute values for this part */
	specs: Array<SupSpec>;
	/** Path component of PDP URL (e.g. `/ad7792bruz-analog+devices-402798`) */
	slug: Scalars["String"];
	/** A link to the part page on Octopart. Do not include `rel="nofollow"` when linking to this URL. */
	octopartUrl: Scalars["String"];
	/** Parts identified by Octopart to be similar in specs and functionality. */
	similarParts: Array<SupPart>;
	/** Parts identified by the manufacturer as companion products. */
	companionProducts: Array<SupSponsoredPart>;
	category?: Maybe<SupCategory>;
	series?: Maybe<SupPartSeries>;
	bestImage?: Maybe<SupImage>;
	bestDatasheet?: Maybe<SupDocument>;
	referenceDesigns: Array<SupReferenceDesign>;
	/** Data about part's CAD model.  If null `cadRequestUrl` can be used to request a CAD model be made. */
	cad?: Maybe<SupPartCad>;
	/** URL to request a CAD model from eeconcierge if a part doesn't already have a CAD model.  Will be null part is not eligible, e.g. a multimeter */
	cadRequestUrl?: Maybe<Scalars["String"]>;
	/** The UID from Octopart APIv3.  Provided for backwards compatibility, in general ID should be used. */
	v3uid: Scalars["ID"];
	/** A [Map](#map) of number of related objects.  Can be used to know the number of `images` or `descriptions` without having to request those related objects. */
	counts: Scalars["Map"];
	/** The median USD price at quantity 1,000, discarding outliers.  A reasonable estimate of average price for a part. */
	medianPrice1000?: Maybe<SupPricePoint>;
	/** Sum of stock available across all distributors */
	totalAvail: Scalars["Int"];
	/** The average stock level at each distributor */
	avgAvail: Scalars["Float"];
	/** Companies with Offers for this part */
	sellers: Array<SupPartSeller>;
	/** The estimated factory lead time in days derived from trusted distributor offers. */
	estimatedFactoryLeadDays?: Maybe<Scalars["Int"]>;
	/** This part might be known by these alternate MPNs */
	akaMpns: Array<Scalars["String"]>;
	extras?: Maybe<SupPartExtras>;
};

/** Part model contains the relevant data around a part, including: datasheets, specs, sellers + offers, images, etc. */
export type SupPartSellersArgs = {
	includeBrokers?: Scalars["Boolean"];
	authorizedOnly?: Scalars["Boolean"];
};

export type SupPartCad = {
	__typename?: "SupPartCad";
	/** URL to add this part to your Upverter library. Requires an Upverter account. */
	addToLibraryUrl?: Maybe<Scalars["String"]>;
	/** If true, a STEP model will be included with the tool-specific downloads. */
	has3dModel: Scalars["Boolean"];
	hasAltium: Scalars["Boolean"];
	hasEagle: Scalars["Boolean"];
	hasOrcad: Scalars["Boolean"];
	hasKicad: Scalars["Boolean"];
	downloadUrlAltium: Scalars["String"];
	downloadUrlEagle: Scalars["String"];
	downloadUrlOrcad: Scalars["String"];
	downloadUrlKicad: Scalars["String"];
	footprintImageUrl?: Maybe<Scalars["String"]>;
	symbolImageUrl?: Maybe<Scalars["String"]>;
};

export type SupPartMatch = {
	__typename?: "SupPartMatch";
	/** Will match `reference` supplied in PartMatchQuery. */
	reference?: Maybe<Scalars["String"]>;
	/** Number of parts matched */
	hits: Scalars["Int"];
	/** Matched parts (may be subset, based on start + limit) */
	parts: Array<SupPart>;
	/** Possible error message */
	error?: Maybe<Scalars["String"]>;
};

export type SupPartResult = {
	__typename?: "SupPartResult";
	/** Cache ID */
	_cacheId: Scalars["String"];
	/** The part object */
	part: SupPart;
	/** @deprecated always empty */
	explain: Scalars["String"];
	/** If the search `q` is an alternate MPN for this part, the `akaMpn` will be populated with this alternate MPN. */
	akaMpn?: Maybe<Scalars["String"]>;
	/**
	 * Description with query terms highlighted.  Often this is the same as part.shortDescription,
	 * but if the search `q` matched on a different description it may be longer than part.shortDescription and require truncation.
	 */
	description: Scalars["String"];
};

/** Result of part search. */
export type SupPartResultSet = {
	__typename?: "SupPartResultSet";
	/** @deprecated use `hits` instead */
	total: Scalars["Int"];
	/** Number of parts in result set */
	hits: Scalars["Int"];
	/** Contains nested part along side some fields specific to the query that explain reason for match. */
	results?: Maybe<Array<SupPartResult>>;
	/** Grouped attributes used to render the columns in specs view. */
	specsViewAttributeGroups: Array<SupAttributeGroup>;
	/** If an invalid query was modified or rejected, warnings indicate this fact to the user.  For example if query contained too many tokens, some tokens may be ignored. */
	warnings?: Maybe<Array<Scalars["String"]>>;
	/**
	 * Perform aggregations on Spec values across multiple Attributes.
	 * You *must* specify `attributeNames` for this field to be populated.
	 * `attributeNames` should be a list of Attribute.shortname values (e.g. `capacitance` or `voltageRatingDc`)
	 */
	specAggs: Array<SupSpecAgg>;
	/** Aggregate on manufacturers for this result set */
	manufacturerAgg: Array<SupCompanyBucket>;
	/** Aggregate on distributors for this result set */
	distributorAgg: Array<SupCompanyBucket>;
	/** Aggregate on categories for this result set */
	categoryAgg: Array<SupCategoryBucket>;
	/** Aggregate on the availability of CAD models for the result set */
	cadAgg: Array<SupCadBucket>;
	/** Categories that are determined by search algo to be related to the search term.  Useful for suggesting a Category filter in the search UI. */
	suggestedCategories: Array<SupCategoryBucket>;
	/** Attributes that are determined by search algo to be related to the search term.  Useful for suggesting most relevant filters in the search UI. */
	suggestedFilters: Array<SupAttribute>;
	/** Full list of available Attributes in the result set */
	allFilters: Array<SupAttribute>;
	/** If a Category filter is applied, this will be the Category */
	appliedCategory?: Maybe<SupCategory>;
	/** If filters are applied, this will contain display information */
	appliedFilters: Array<SupAppliedFilter>;
};

/** Result of part search. */
export type SupPartResultSetSpecAggsArgs = {
	attributeNames: Array<Scalars["String"]>;
	size?: Scalars["Int"];
};

/** Result of part search. */
export type SupPartResultSetManufacturerAggArgs = {
	size?: Scalars["Int"];
};

/** Result of part search. */
export type SupPartResultSetDistributorAggArgs = {
	size?: Scalars["Int"];
};

/** Result of part search. */
export type SupPartResultSetCategoryAggArgs = {
	size?: Scalars["Int"];
};

/** A company with offers for a given part */
export type SupPartSeller = {
	__typename?: "SupPartSeller";
	/** Cache ID */
	_cacheId: Scalars["String"];
	/** The distributor */
	company: SupCompany;
	/** Distributor's country */
	country?: Maybe<Scalars["String"]>;
	/**
	 * List of offers.  Multiple offers may exist in different packaging.
	 * While multiple geo-targeted offers may exist, currently the API only exposes one geo-targeted offer at a time based on `country` parameter.
	 * Please contact us if you have a need to see all geo-targeted offer variants.
	 */
	offers: Array<SupOffer>;
	/** True if the distributor is an authorized distributor for this manufacturer.  See [authorized](https://octopart.com/authorized) for more information. */
	isAuthorized: Scalars["Boolean"];
	/** True if the distributor is a Non-Authorized Dealer.  See [authorized](https://octopart.com/authorized) for more information. */
	isBroker: Scalars["Boolean"];
	/** True if you can request a quote from this seller. */
	isRfq: Scalars["Boolean"];
	/** List of countries the seller ships to. An empty list represents zero shipping restrictions. */
	shipsToCountries: Array<SupCountry>;
};

/**
 * A Part can be a member of a PartSeries, which represents a product line or "family" of parts from the manufacturer.
 *
 * See [series](https://octopart.com/series) page for examples.
 */
export type SupPartSeries = {
	__typename?: "SupPartSeries";
	/** Octopart internal ID for this series */
	id: Scalars["ID"];
	/** Name of the part series */
	name: Scalars["String"];
	/** Octopart URL for this series, specific to the parent part */
	url: Scalars["String"];
};

/** Price in a specific currency + quantity.  By supplying a `currency` parameter the API will populate an estimated convertedPrice in the user's desired currency. */
export type SupPricePoint = {
	__typename?: "SupPricePoint";
	/** Cache ID */
	_cacheId: Scalars["String"];
	/** Minimum purchase quantity to get this price (aka price break) */
	quantity: Scalars["Int"];
	/** Price in currency */
	price: Scalars["Float"];
	/** Currency for price */
	currency: Scalars["String"];
	/**
	 * Price converted to user's currency using foreign exchange rates.
	 *
	 * Since this is an estimate, an indicator should be shown to user if currency != convertedCurrency.
	 */
	convertedPrice: Scalars["Float"];
	/** Currency for `convertedPrice`.  Will match value of `currency` argument. */
	convertedCurrency: Scalars["String"];
	/** The exchange rate used to calculate convertedPrice */
	conversionRate: Scalars["Float"];
};

export type SupReferenceDesign = {
	__typename?: "SupReferenceDesign";
	name: Scalars["String"];
	url: Scalars["String"];
};

/** Represents a specific value of an Attribute for a given Part */
export type SupSpec = {
	__typename?: "SupSpec";
	attribute: SupAttribute;
	/** The actual value */
	value: Scalars["String"];
	/** The type of the value */
	valueType: Scalars["String"];
	/** The units of the value */
	units: Scalars["String"];
	/** The short name of the units */
	unitsName: Scalars["String"];
	/** The symbol of the units */
	unitsSymbol: Scalars["String"];
	/** The formatted display value */
	displayValue: Scalars["String"];
};

export type SupSpecAgg = {
	__typename?: "SupSpecAgg";
	attribute: SupAttribute;
	buckets: Array<SupSpecBucket>;
	/** min is the lowest spec value in this result set for numerical attributes */
	min?: Maybe<Scalars["Float"]>;
	/** max is the greatest spec value in this result set for numerical attributes */
	max?: Maybe<Scalars["Float"]>;
	/** displayMin is the formatted string of min */
	displayMin?: Maybe<Scalars["String"]>;
	/** displayMax is the formatted string of max */
	displayMax?: Maybe<Scalars["String"]>;
	/** The type of the value */
	valueType: Scalars["String"];
	/** The units of the spec */
	units?: Maybe<Scalars["String"]>;
	/** The short name of the units */
	unitsName?: Maybe<Scalars["String"]>;
	/** The symbol of the units */
	unitsSymbol?: Maybe<Scalars["String"]>;
};

export type SupSpecBucket = {
	__typename?: "SupSpecBucket";
	/** displayValue is the string value. For numerical attributes it is the formatted version of floatValue */
	displayValue: Scalars["String"];
	/** floatValue is populated if the attribute is numeric */
	floatValue?: Maybe<Scalars["Float"]>;
	/** count will be null if aggregation timed out */
	count?: Maybe<Scalars["Int"]>;
};

export type SupSpellingCorrection = {
	__typename?: "SupSpellingCorrection";
	correctionString: Scalars["String"];
	hits: Scalars["Int"];
};

/** Part identified by manufacturer as being a companion part, for instance a mated connector pair. */
export type SupSponsoredPart = {
	__typename?: "SupSponsoredPart";
	/** Cache ID */
	_cacheId: Scalars["String"];
	/** @deprecated use part.id instead */
	ppid: Scalars["ID"];
	/** @deprecated unused */
	sourceId: Scalars["ID"];
	/** Related part */
	part: SupPart;
	/** URL to visit for related part */
	url: Scalars["String"];
};

/** Suggests a query based on partial query input.  Used for autocomplete / typeahead UIs. */
export type SupSuggestion = {
	__typename?: "SupSuggestion";
	/** Suggested text of longer query */
	text: Scalars["String"];
	/** If the suggestion should also apply a categoryId filter, this is the category name */
	inCategoryName: Scalars["String"];
	/** If the suggestion should also apply a categoryId filter, this is the Category ID */
	inCategoryId: Scalars["String"];
};

export type SupApiCredentials = {
	/** The name of the API that you are providing credentials for. An Octopart representative will give this value to you if needed. */
	apiName: Scalars["String"];
	/** Authentication details. `clientId` and `clientSecret` should be given together when an API requires them. */
	clientId?: Maybe<Scalars["String"]>;
	/** Authentication details. `clientId` and `clientSecret` should be given together when an API requires them. */
	clientSecret?: Maybe<Scalars["String"]>;
	/** Authentication details. `username` and `password` should be given together when an API requires them. */
	username?: Maybe<Scalars["String"]>;
	/** Authentication details. `username` and `password` should be given together when an API requires them. */
	password?: Maybe<Scalars["String"]>;
};

export type SupPartMatchOptions = {
	/** If true, only parts with at least one authorized seller will be returned. */
	requireAuthorizedSellers?: Maybe<Scalars["Boolean"]>;
	/** If true, only parts with stock available will be returned. */
	requireStockAvailable?: Maybe<Scalars["Boolean"]>;
	/** a key: value map of filters. See [filter values](https://octopart.com/api/v4/values#filters) */
	filters?: Maybe<Scalars["Map"]>;
};

export type SupPartMatchQuery = {
	mpn?: Maybe<Scalars["String"]>;
	sku?: Maybe<Scalars["String"]>;
	mpnOrSku?: Maybe<Scalars["String"]>;
	manufacturer?: Maybe<Scalars["String"]>;
	seller?: Maybe<Scalars["String"]>;
	start?: Scalars["Int"];
	limit?: Scalars["Int"];
	reference?: Maybe<Scalars["String"]>;
};

export enum SupPlanTier {
	Free = "FREE",
	Basic = "BASIC",
	Pro = "PRO",
	Enterprise = "ENTERPRISE"
}

export enum SupRole {
	Distributor = "DISTRIBUTOR",
	Cadmodels = "CADMODELS",
	Internal = "INTERNAL"
}

export enum SupSortDirection {
	Asc = "asc",
	Desc = "desc"
}

export type ManOrderEvent = {
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManAabb = {
	__typename?: "ManAABB";
	topLeft?: Maybe<ManPoint2D>;
	bottomRight?: Maybe<ManPoint2D>;
	area?: Maybe<ManArea>;
};

export type ManAngle = {
	__typename?: "ManAngle";
	native?: Maybe<Scalars["Int"]>;
	radians?: Maybe<Scalars["Float"]>;
	degrees?: Maybe<Scalars["Float"]>;
};

export type ManArea = {
	__typename?: "ManArea";
	native?: Maybe<Scalars["Int"]>;
	mm2?: Maybe<Scalars["Float"]>;
	mil2?: Maybe<Scalars["Float"]>;
	inSq?: Maybe<Scalars["Float"]>;
};

export type ManAssembly = {
	__typename?: "ManAssembly";
	id?: Maybe<Scalars["ID"]>;
	boardMeta?: Maybe<ManBoardMeta>;
	projectId?: Maybe<Scalars["ID"]>;
	commitId?: Maybe<Scalars["ID"]>;
	variant?: Maybe<Scalars["String"]>;
	bomSelection?: Maybe<Scalars["ID"]>;
	package?: Maybe<ManPackageJob>;
};

export type ManBoardDetails = {
	__typename?: "ManBoardDetails";
	path?: Maybe<Array<Maybe<ManPathSegment>>>;
	polygon?: Maybe<Array<Maybe<ManPoint2D>>>;
	aabb?: Maybe<ManAabb>;
};

export type ManBoardDetailsPolygonArgs = {
	quant: Scalars["Int"];
};

export type ManBoardMeta = {
	__typename?: "ManBoardMeta";
	id?: Maybe<Scalars["ID"]>;
	projectId?: Maybe<Scalars["String"]>;
	boardDetails?: Maybe<ManBoardDetails>;
	parts?: Maybe<Array<Maybe<ManPart>>>;
	consignmentCount: Scalars["Int"];
	bomIssues: ManBomIssues;
	placementStats?: Maybe<ManPlacementInfo>;
	minClearance?: Maybe<ManLength>;
	minAnnularRing?: Maybe<ManLength>;
	stackUp?: Maybe<Array<Maybe<ManLayer>>>;
};

export type ManBomIssues = {
	__typename?: "ManBomIssues";
	issueCount: Scalars["Int"];
	warningCount: Scalars["Int"];
};

export type ManBomResolution = {
	__typename?: "ManBomResolution";
	parts: Array<ManPart>;
};

export type ManConsignmentDocs = {
	__typename?: "ManConsignmentDocs";
	pdf: Scalars["String"];
	html: Scalars["String"];
};

export type ManCreateAssemblyResponse = {
	__typename?: "ManCreateAssemblyResponse";
	assembly?: Maybe<ManAssembly>;
};

export type ManCreateOrderResponse = {
	__typename?: "ManCreateOrderResponse";
	order?: Maybe<ManOrder>;
};

export type ManLayer = {
	__typename?: "ManLayer";
	type?: Maybe<ManLayerType>;
	thickness?: Maybe<ManLength>;
	copperWeight?: Maybe<Scalars["Float"]>;
	overlayColour?: Maybe<ManSilkScreenColour>;
	maskColour?: Maybe<ManSolderMaskColour>;
	process?: Maybe<Scalars["String"]>;
	material?: Maybe<Scalars["String"]>;
};

export type ManLength = {
	__typename?: "ManLength";
	mm?: Maybe<Scalars["Float"]>;
	mil?: Maybe<Scalars["Float"]>;
	inch?: Maybe<Scalars["Float"]>;
	/** native units of 1/10000 of a mil */
	native?: Maybe<Scalars["Int"]>;
};

export type ManOffer = {
	__typename?: "ManOffer";
	price?: Maybe<ManPrice>;
	minQty?: Maybe<Scalars["Int"]>;
};

export type ManOrder = {
	__typename?: "ManOrder";
	id?: Maybe<Scalars["ID"]>;
	reference?: Maybe<Scalars["String"]>;
	createdBy?: Maybe<ManUser>;
	createdAt?: Maybe<Scalars["DateTime"]>;
	shipDate?: Maybe<Scalars["DateTime"]>;
	boardName?: Maybe<Scalars["String"]>;
	boardPreview?: Maybe<Scalars["String"]>;
	stripeSecret?: Maybe<Scalars["ID"]>;
	checkoutURL?: Maybe<Scalars["String"]>;
	rapidQuote?: Maybe<ManQuoteInfo>;
	assembly?: Maybe<ManAssembly>;
	shipping?: Maybe<ManShippingDetails>;
	status?: Maybe<ManOrderStatus>;
	events?: Maybe<Array<Maybe<ManOrderEvent>>>;
};

export type ManOrderAcceptedEvent = ManOrderEvent & {
	__typename?: "ManOrderAcceptedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderBatchedEvent = ManOrderEvent & {
	__typename?: "ManOrderBatchedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderCancelEvent = ManOrderEvent & {
	__typename?: "ManOrderCancelEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderConsignmentDetailsEvent = ManOrderEvent & {
	__typename?: "ManOrderConsignmentDetailsEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
	shipping: ManShippingDetails;
	receiveBy: Scalars["DateTime"];
	consignmentId: Scalars["ID"];
	documents: ManConsignmentDocs;
	parts: Array<ManPartQuantity>;
};

export type ManOrderCreatedEvent = ManOrderEvent & {
	__typename?: "ManOrderCreatedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderEmsAcceptedEvent = ManOrderEvent & {
	__typename?: "ManOrderEmsAcceptedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderPaidEvent = ManOrderEvent & {
	__typename?: "ManOrderPaidEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderPartsOrderedEvent = ManOrderEvent & {
	__typename?: "ManOrderPartsOrderedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderPartsReceivedEvent = ManOrderEvent & {
	__typename?: "ManOrderPartsReceivedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderPcbsOrderedEvent = ManOrderEvent & {
	__typename?: "ManOrderPcbsOrderedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderPcbsReceivedEvent = ManOrderEvent & {
	__typename?: "ManOrderPcbsReceivedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderProcessStartEvent = ManOrderEvent & {
	__typename?: "ManOrderProcessStartEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderReceivedEvent = ManOrderEvent & {
	__typename?: "ManOrderReceivedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderReviewedEvent = ManOrderEvent & {
	__typename?: "ManOrderReviewedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderShipEstimateEvent = ManOrderEvent & {
	__typename?: "ManOrderShipEstimateEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
};

export type ManOrderShippedEvent = ManOrderEvent & {
	__typename?: "ManOrderShippedEvent";
	id: Scalars["ID"];
	order: ManOrder;
	eventType: ManOrderEventType;
	timestamp: Scalars["Int"];
	trackingNumber: Scalars["String"];
	carrier: ManShippingCarrier;
	trackingLink: Scalars["String"];
};

export type ManPackageJob = {
	__typename?: "ManPackageJob";
	id?: Maybe<Scalars["ID"]>;
	status?: Maybe<Scalars["String"]>;
	errors?: Maybe<Array<Maybe<Scalars["String"]>>>;
};

export type ManPart = {
	__typename?: "ManPart";
	id?: Maybe<Scalars["ID"]>;
	pinCount?: Maybe<Scalars["Int"]>;
	type?: Maybe<ManMountingType>;
	partChoices?: Maybe<Array<Maybe<ManPartChoice>>>;
	selectedChoice?: Maybe<ManPartChoice>;
	name?: Maybe<Scalars["String"]>;
	comment?: Maybe<Scalars["String"]>;
	description?: Maybe<Scalars["String"]>;
	sourcing: ManSourcing;
	placements?: Maybe<Array<Maybe<ManPlacement>>>;
	placementCount?: Maybe<Scalars["Int"]>;
	issues: Array<ManPartIssue>;
	status?: Maybe<ManPartStatus>;
};

export type ManPartChoice = {
	__typename?: "ManPartChoice";
	mpn?: Maybe<Scalars["String"]>;
	manufacturer?: Maybe<Scalars["String"]>;
	suppliers?: Maybe<Array<Maybe<ManPurchaseOption>>>;
	description?: Maybe<Scalars["String"]>;
	lifecycle?: Maybe<Scalars["String"]>;
	octopartId?: Maybe<Scalars["String"]>;
	image?: Maybe<Scalars["String"]>;
	octopartUrl?: Maybe<Scalars["String"]>;
};

export type ManPartQuantity = {
	__typename?: "ManPartQuantity";
	reference: Scalars["String"];
	quantity: Scalars["Int"];
	linkedPart?: Maybe<ManPartChoice>;
	placements: Array<ManPlacement>;
};

export type ManPathSegment = {
	__typename?: "ManPathSegment";
	type?: Maybe<ManPathType>;
	vertex?: Maybe<ManPoint2D>;
	startAngle?: Maybe<ManAngle>;
	endAngle?: Maybe<ManAngle>;
	radius?: Maybe<ManLength>;
};

export type ManPlacement = {
	__typename?: "ManPlacement";
	refdes?: Maybe<Scalars["String"]>;
	location?: Maybe<ManPoint2D>;
	side?: Maybe<ManSide>;
	size?: Maybe<ManPoint2D>;
	aabb?: Maybe<ManAabb>;
};

export type ManPlacementInfo = {
	__typename?: "ManPlacementInfo";
	bomLines?: Maybe<Scalars["Int"]>;
	totalPlacements?: Maybe<Scalars["Int"]>;
	thPlacements?: Maybe<Scalars["Int"]>;
	smtPlacements?: Maybe<Scalars["Int"]>;
	topPlacements?: Maybe<Scalars["Int"]>;
	botPlacements?: Maybe<Scalars["Int"]>;
	dualSided?: Maybe<Scalars["Boolean"]>;
};

export type ManPoint2D = {
	__typename?: "ManPoint2D";
	x?: Maybe<ManLength>;
	y?: Maybe<ManLength>;
};

export type ManPrice = {
	__typename?: "ManPrice";
	amount?: Maybe<Scalars["Decimal"]>;
	currency?: Maybe<ManCurrency>;
};

export type ManPurchaseOption = {
	__typename?: "ManPurchaseOption";
	supplier?: Maybe<Scalars["String"]>;
	inventory?: Maybe<Scalars["Int"]>;
	sku?: Maybe<Scalars["String"]>;
	offers?: Maybe<Array<Maybe<ManOffer>>>;
};

export type ManQuote = {
	__typename?: "ManQuote";
	id: Scalars["ID"];
	type?: Maybe<Scalars["String"]>;
	items?: Maybe<Array<Maybe<ManQuoteItem>>>;
	leadtime?: Maybe<Scalars["Int"]>;
	total?: Maybe<Scalars["Decimal"]>;
	violations?: Maybe<Array<Maybe<ManViolation>>>;
	valid?: Maybe<Scalars["Boolean"]>;
};

export type ManQuoteInfo = {
	__typename?: "ManQuoteInfo";
	selectedQuote?: Maybe<ManQuote>;
	quoteRequest?: Maybe<ManRapidQuoteRequest>;
	response?: Maybe<ManRapidQuoteResponse>;
};

export type ManQuoteItem = {
	__typename?: "ManQuoteItem";
	category?: Maybe<ManQuoteCategory>;
	amount?: Maybe<Scalars["Decimal"]>;
	ident?: Maybe<Scalars["String"]>;
};

export type ManRapidQuoteRequest = {
	__typename?: "ManRapidQuoteRequest";
	id?: Maybe<Scalars["ID"]>;
	qty?: Maybe<Scalars["Int"]>;
	meta?: Maybe<ManBoardMeta>;
	shipping?: Maybe<ManShippingDetails>;
	bomResolutionUrl?: Maybe<Scalars["String"]>;
	requestorId?: Maybe<Scalars["ID"]>;
};

export type ManRapidQuoteResponse = {
	__typename?: "ManRapidQuoteResponse";
	id?: Maybe<Scalars["ID"]>;
	request?: Maybe<ManRapidQuoteRequest>;
	quotes?: Maybe<Array<Maybe<ManQuote>>>;
};

export type ManRapidQuoteResponseQuotesArgs = {
	wait?: Maybe<Scalars["Int"]>;
};

export type ManShippingDetails = {
	__typename?: "ManShippingDetails";
	name?: Maybe<Scalars["String"]>;
	email?: Maybe<Scalars["String"]>;
	phone?: Maybe<Scalars["String"]>;
	line1?: Maybe<Scalars["String"]>;
	line2?: Maybe<Scalars["String"]>;
	country?: Maybe<Scalars["String"]>;
	city?: Maybe<Scalars["String"]>;
	state?: Maybe<Scalars["String"]>;
	postal?: Maybe<Scalars["String"]>;
	method?: Maybe<ManShippingMethod>;
};

export type ManShippingMethod = {
	__typename?: "ManShippingMethod";
	carrier?: Maybe<Scalars["String"]>;
	service?: Maybe<Scalars["String"]>;
};

export type ManUser = {
	__typename?: "ManUser";
	/** The internal user ID. */
	userId: Scalars["String"];
	/** Null if the user no longer exists. */
	userName?: Maybe<Scalars["String"]>;
	/** Null if the user no longer exists. */
	email?: Maybe<Scalars["String"]>;
	/** Null if the user no longer exists. */
	firstName?: Maybe<Scalars["String"]>;
	/** Null if the user no longer exists. */
	lastName?: Maybe<Scalars["String"]>;
};

export type ManViolation = {
	__typename?: "ManViolation";
	/**
	 * dot delimited string describing location of issue
	 * layers.[1].process
	 */
	field?: Maybe<Scalars["String"]>;
	type?: Maybe<ManViolationType>;
	description?: Maybe<Scalars["String"]>;
};

export type ManAabbInput = {
	topLeft?: Maybe<ManPoint2DInput>;
	bottomRight?: Maybe<ManPoint2DInput>;
};

export type ManBoardMetaInput = {
	projectId?: Maybe<Scalars["String"]>;
	boardOutline?: Maybe<Array<Maybe<ManPathSegmentInput>>>;
	parts?: Maybe<Array<Maybe<ManPartInput>>>;
	minClearance?: Maybe<Scalars["Int"]>;
	minAnnularRing?: Maybe<Scalars["Int"]>;
	stackUp?: Maybe<Array<Maybe<ManLayerInput>>>;
};

export type ManLayerInput = {
	type?: Maybe<ManLayerType>;
	thickness?: Maybe<Scalars["Int"]>;
	copperWeight?: Maybe<Scalars["Float"]>;
	overlayColour?: Maybe<ManSilkScreenColour>;
	maskColour?: Maybe<ManSolderMaskColour>;
	process?: Maybe<Scalars["String"]>;
	material?: Maybe<Scalars["String"]>;
};

export type ManOfferInput = {
	price?: Maybe<ManPriceInput>;
	minQty?: Maybe<Scalars["Int"]>;
};

export type ManOrderBatchedInput = {
	orderId: Scalars["ID"];
};

export type ManOrderConsignmentDetailsInput = {
	orderId: Scalars["ID"];
	shipping: ManShippingDetailsInput;
	receiveBy: Scalars["DateTime"];
	consignmentId: Scalars["ID"];
	partQuantities: Array<ManPartQuantityInput>;
};

export type ManOrderEmsAcceptInput = {
	orderId: Scalars["ID"];
	emsReference?: Maybe<Scalars["String"]>;
};

export type ManOrderPartsOrderedInput = {
	orderId: Scalars["ID"];
};

export type ManOrderPartsReceivedInput = {
	orderId: Scalars["ID"];
};

export type ManOrderPcbsOrderedInput = {
	orderId: Scalars["ID"];
};

export type ManOrderPcbsReceivedInput = {
	orderId: Scalars["ID"];
};

export type ManOrderProcessStartInput = {
	orderId: Scalars["ID"];
};

export type ManOrderReviewInput = {
	orderId: Scalars["ID"];
};

export type ManOrderShipEstimateInput = {
	orderId: Scalars["ID"];
	estimateDate: Scalars["DateTime"];
};

export type ManOrderShippedInput = {
	orderId: Scalars["ID"];
	trackingNumber?: Maybe<Scalars["String"]>;
	carrier?: Maybe<ManShippingCarrier>;
};

export type ManPartChoiceInput = {
	mpn?: Maybe<Scalars["String"]>;
	manufacturer?: Maybe<Scalars["String"]>;
	octopartId?: Maybe<Scalars["String"]>;
	suppliers?: Maybe<Array<Maybe<ManPurchaseOptionInput>>>;
};

export type ManPartInput = {
	id?: Maybe<Scalars["ID"]>;
	componentId?: Maybe<Scalars["ID"]>;
	type?: Maybe<ManMountingType>;
	pinCount?: Maybe<Scalars["Int"]>;
	partChoices?: Maybe<Array<Maybe<ManPartChoiceInput>>>;
	placements?: Maybe<Array<Maybe<ManPlacementInput>>>;
};

export type ManPartQuantityInput = {
	id: Scalars["ID"];
	amount: Scalars["Int"];
};

export type ManPartSelectionInput = {
	part: Scalars["ID"];
	selection: Scalars["ID"];
	sourcing: ManSourcing;
};

export type ManPathSegmentInput = {
	type?: Maybe<ManPathType>;
	/** Either center of a circle for the arc, or the vertex location */
	vertex?: Maybe<ManPoint2DInput>;
	/** start point of arc in billionth of a rotation (range from 0 to 999999999) */
	startAngle?: Maybe<Scalars["Int"]>;
	/** end point of arc in billionth of a rotation (range from 0 to 999999999) */
	endAngle?: Maybe<Scalars["Int"]>;
	/** radius of the circle if an arc */
	radius?: Maybe<Scalars["Int"]>;
};

export type ManPlacementInput = {
	/** schematic refdes */
	refdes?: Maybe<Scalars["String"]>;
	/** Location of the part */
	location?: Maybe<ManPoint2DInput>;
	/** Side of the board */
	side?: Maybe<ManSide>;
	/** aabb of the part */
	aabb?: Maybe<ManAabbInput>;
};

export type ManPoint2DInput = {
	x: Scalars["Int"];
	y: Scalars["Int"];
};

export type ManPriceInput = {
	amount?: Maybe<Scalars["Decimal"]>;
};

export type ManPurchaseOptionInput = {
	supplier?: Maybe<Scalars["String"]>;
	inventory?: Maybe<Scalars["Int"]>;
	offers?: Maybe<Array<Maybe<ManOfferInput>>>;
};

export type ManQuoteInput = {
	id: Scalars["ID"];
	type?: Maybe<Scalars["String"]>;
	/** the quote line items */
	items?: Maybe<Array<Maybe<ManQuoteInputItem>>>;
	/** leadtime in business days */
	leadtime?: Maybe<Scalars["Int"]>;
	/** any parameter violation which invalidate the quote */
	violations?: Maybe<Array<Maybe<ManViolationInput>>>;
};

export type ManQuoteInputItem = {
	category?: Maybe<ManQuoteCategory>;
	amount?: Maybe<Scalars["Decimal"]>;
	ident?: Maybe<Scalars["String"]>;
};

export type ManShippingDetailsInput = {
	name?: Maybe<Scalars["String"]>;
	email?: Maybe<Scalars["String"]>;
	phone?: Maybe<Scalars["String"]>;
	line1?: Maybe<Scalars["String"]>;
	line2?: Maybe<Scalars["String"]>;
	country?: Maybe<Scalars["String"]>;
	city?: Maybe<Scalars["String"]>;
	state?: Maybe<Scalars["String"]>;
	postal?: Maybe<Scalars["String"]>;
	method?: Maybe<ManShippingMethodInput>;
};

export type ManShippingMethodInput = {
	carrier?: Maybe<Scalars["String"]>;
	service?: Maybe<Scalars["String"]>;
};

export type ManViolationInput = {
	/**
	 * dot delimited string describing location of issue
	 * layers.[1].process
	 */
	field?: Maybe<Scalars["String"]>;
	type?: Maybe<ManViolationType>;
	description?: Maybe<Scalars["String"]>;
};

export enum ManAccess {
	AllowMpn = "ALLOW_MPN",
	IsEms = "IS_EMS",
	IsCreator = "IS_CREATOR"
}

export enum ManCurrency {
	Usd = "USD"
}

export enum ManLayerType {
	Coverlay = "COVERLAY",
	SurfaceFinish = "SURFACE_FINISH",
	Signal = "SIGNAL",
	Plane = "PLANE",
	Core = "CORE",
	PrePreg = "PRE_PREG",
	SolderMask = "SOLDER_MASK",
	Overlay = "OVERLAY"
}

export enum ManMountingType {
	ThroughHole = "THROUGH_HOLE",
	SurfaceMount = "SURFACE_MOUNT"
}

export enum ManOrderEventType {
	Created = "CREATED",
	Accepted = "ACCEPTED",
	EmsAccepted = "EMS_ACCEPTED",
	Paid = "PAID",
	ConsignmentDetails = "CONSIGNMENT_DETAILS",
	TimeEstimation = "TIME_ESTIMATION",
	Reviewed = "REVIEWED",
	Batched = "BATCHED",
	PartsOrdered = "PARTS_ORDERED",
	PcbsOrdered = "PCBS_ORDERED",
	PartsReceived = "PARTS_RECEIVED",
	PcbsReceived = "PCBS_RECEIVED",
	ProcessStart = "PROCESS_START",
	Shipped = "SHIPPED",
	Received = "RECEIVED",
	Cancel = "CANCEL"
}

export enum ManOrderStatus {
	Quoting = "QUOTING",
	PaymentProcessing = "PAYMENT_PROCESSING",
	Placed = "PLACED",
	Processing = "PROCESSING",
	Manufacturing = "MANUFACTURING",
	Shipping = "SHIPPING",
	Cancelled = "CANCELLED",
	Complete = "COMPLETE"
}

export enum ManPartIssue {
	BadLifecycle = "BAD_LIFECYCLE",
	NoSelection = "NO_SELECTION",
	Unavailable = "UNAVAILABLE",
	NotFound = "NOT_FOUND",
	InsufficientStock = "INSUFFICIENT_STOCK",
	StockLow = "STOCK_LOW"
}

export enum ManPartStatus {
	Good = "GOOD",
	Warn = "WARN",
	Issue = "ISSUE"
}

export enum ManPathType {
	Arc = "ARC",
	Vertex = "VERTEX"
}

export enum ManQuoteCategory {
	Fabrication = "FABRICATION",
	Assembly = "ASSEMBLY",
	Bom = "BOM",
	Shipping = "SHIPPING",
	Nre = "NRE"
}

export enum ManShippingCarrier {
	Usps = "USPS",
	Ups = "UPS"
}

export enum ManSide {
	Top = "TOP",
	Bottom = "BOTTOM"
}

export enum ManSilkScreenColour {
	Yellow = "YELLOW",
	Red = "RED",
	Green = "GREEN",
	Blue = "BLUE",
	Black = "BLACK",
	White = "WHITE"
}

export enum ManSolderMaskColour {
	Blue = "BLUE",
	Red = "RED",
	Green = "GREEN",
	LightGreen = "LIGHT_GREEN",
	MatteGreen = "MATTE_GREEN",
	Yellow = "YELLOW",
	Black = "BLACK",
	MatteBlack = "MATTE_BLACK",
	White = "WHITE",
	DarkBrown = "DARK_BROWN",
	Transparent = "TRANSPARENT"
}

export enum ManSourcing {
	Altimade = "ALTIMADE",
	Consign = "CONSIGN",
	Dnp = "DNP"
}

export enum ManViolationType {
	Inconsistent = "INCONSISTENT",
	TooBig = "TOO_BIG",
	TooSmall = "TOO_SMALL",
	Unknown = "UNKNOWN",
	Unsupported = "UNSUPPORTED"
}

/** An application belonging to an organization which facilitates access. Users interact with the Nexar API through applications. */
export type AdmApplication = {
	__typename?: "AdmApplication";
	/** The scopes assigned to this application. */
	scopes: Array<AdmApplicationScope>;
	/** Information about supply quota if this application has the supply scope. */
	supplyCounts?: Maybe<AdmSupplyCounts>;
	/** Security detail for this application, such as its client id and secret. */
	security: AdmApplicationSecurity;
	/** The organization to which this application belongs. */
	organizationId?: Maybe<Scalars["String"]>;
	/** The name of this application. */
	name: Scalars["String"];
	/** The description of this application. */
	description?: Maybe<Scalars["String"]>;
	/** Whether or not this application has been deleted. */
	deleted: Scalars["Boolean"];
	/** When this application was created. */
	createdDate: Scalars["DateTime"];
	/** A unique identifier for the application. */
	id: Scalars["String"];
};

/** A scope for an application, e.g. design, supply or manufacturing. */
export type AdmApplicationScope = {
	__typename?: "AdmApplicationScope";
	/** The application to which this scope applies. */
	applicationId: Scalars["String"];
	/** The scope to which the application has been granted access. */
	scope: Scalars["String"];
};

/** Security access details for an application. */
export type AdmApplicationSecurity = {
	__typename?: "AdmApplicationSecurity";
	/** The application to which this scope applies. */
	applicationId: Scalars["String"];
	/** The unique client id for this application. */
	clientId: Scalars["String"];
	/** The unique client secret for this application. Guard this secret carefully! */
	clientSecret: Scalars["String"];
};

/** An Organization is an entity representing a partner, company or individual engaging with Nexar. */
export type AdmOrganization = {
	__typename?: "AdmOrganization";
	/** The users belonging to this organization. */
	users: Array<AdmUser>;
	/** Invitations sent for others to join this organization. */
	invitations: Array<AdmUserInvitation>;
	/** The applications belonging to this organization through which users interact with the API. */
	applications: Array<AdmApplication>;
	/** Whether this is the current user's default organization. */
	isDefault: Scalars["Boolean"];
	/** The name of this organization. */
	name: Scalars["String"];
	/** When this organization was created. */
	createdDate: Scalars["DateTime"];
	/** A unique identifier for the organization. */
	id: Scalars["String"];
};

/** Supply count information for supply applications. */
export type AdmSupplyCounts = {
	__typename?: "AdmSupplyCounts";
	/** The count of supply parts used this month. */
	partCounter: Scalars["Int"];
	/** The monthly quota of parts which can be returned through supply API queries. */
	partLimit: Scalars["Int"];
};

/** A user represents and individual who can login to Nexar and interact with API through applications of this organization. */
export type AdmUser = {
	__typename?: "AdmUser";
	/** The email address for the user used as their username. */
	userName: Scalars["String"];
	/** The user's first name. */
	firstName: Scalars["String"];
	/** The user's last name. */
	lastName: Scalars["String"];
	/** When the user was created in the system. */
	createdDate: Scalars["DateTime"];
	/** A unique identifier for the user. */
	id: Scalars["String"];
};

/** An invitation sent for a user to join an invitation. */
export type AdmUserInvitation = {
	__typename?: "AdmUserInvitation";
	/** The organization to which the user has been invited. */
	organizationId?: Maybe<Scalars["String"]>;
	/** The email of the user receiving the invitation to join the organization. */
	email?: Maybe<Scalars["String"]>;
	/** Whether or not the user accepted the invitation to join the organization. */
	accepted: Scalars["Boolean"];
};

export enum ApplyPolicy {
	BeforeResolver = "BEFORE_RESOLVER",
	AfterResolver = "AFTER_RESOLVER"
}
